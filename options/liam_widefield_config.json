{
	// ===========================================================================================
	// ============================ General Parameters ===========================================
	// ===========================================================================================
	"base_dir": {}, // base_dir not required, if not "" it is prepended to filepath
    "filepath": {}, // specify path to raw data. 
    // In metres
    "raw_pixel_size": {
        "option_default": 222e-9
    },
    // =======================================
    // === Custom output directory control ===
    // Any option key can be interpolated (to options[key]) with braces (like f-strings)
    // e.g. "ODMR_{fit_backend}" -> "ODMR_scipy" if the fit backend was scipy
    // Note all whitespace will be converted to underscore
    "custom_output_dir_prefix": {
        "option_default": null
    },
    "custom_output_dir_suffix": {
        "option_default": null
    },
    // Must be an absolute path (e.g. from root/C:), will override the path determined internally.
    "custom_output_dir": {
        "option_default": null
    },
    // =======================================
        
    // if true the reference measurement is ignored
    "ignore_ref": {
    	"option_default": false,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },

    // additional binning on dataset (local averaging), 0 does nothing. Must be multiple of 2
    "additional_bins": {
    	"option_default": 0
    },

    // legacy option
    "old_binning_convention": {
    	"option_default": false,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },

    // Required - name of system used (see systems.py)
    "system_name": {
        "option_default": "LiamsWidefield",
    	"option_choices":
    		[
    			"Zyla",
                "Liams_Widefield"
    		]
    },
	// ===========================================================================================
    // ======================== Region Of Interest (ROI) params ==================================
	// ===========================================================================================
    // For taking a region of interest and ignoring the rest qof the data set
    "ROI": {
        "option_default": "Full",
        "option_choices":
            [
                "Full",
                "Rectangle"         ]
    },
    // Start of ROI region (indices, [start_x, start_y]) i.e. top left corner
    "ROI_start": {
        "option_default": 0
    },    
    // End of ROI region (indices, [end_x, end_y]) i.e. bottom right corner
    "ROI_end": {
        "option_default": 0
    },    
    // Removes data points from the start and end of each pixel data
    "remove_start_sweep": {
        "option_default": 1
    },
    "remove_end_sweep": {
        "option_default": 0
    },

    // Style of the reference normalisation used. div = division and sub = subtraction
    // Note: subtraction adds '1', i.e. 1 + sig - ref
    "normalisation": {
    	"option_default": "div",
    	"option_choices":
    		[
    			"div",
    			"sub"
    		]
    },

    // ========== Regions for spectra comparision, before full pixel fitting ==========
    // single pixel location that is used
    "single_pixel_check": {
    	"option_default": [1, 1]
    },
    // start indices (top left corner) of area 1, [start_x, start_y]
    "AOI_1_start": {
        "option_default": [1, 1]
    },
    // end indices [end_x, end_y] of the square region of area 1
    "AOI_1_end": {
        "option_default": [2, 2]
    },
    // etc. for as many as you like: need to be copied/extended below if you want more AOIs
    "AOI_2_start": {
    },
    "AOI_2_end": {
    },
    "AOI_3_start": {
    },
    "AOI_3_end": {
    },
    "AOI_4_start": {
    },
    "AOI_4_end": {
    },
    "AOI_5_start": {
    },
    "AOI_5_end": {
    },


    // ========== Fitting Parameters ==========
    // Backend used for pixel fitting (required)
    "fit_backend": {
        "option_default": "scipyfit",
        "option_choices":
            [
                "scipyfit"
            ]
    },
    // Backends compared in ROI/AOI spectra comparisons
    "fit_backend_comparison": {
        "option_default": [
            "scipyfit"
        ]
    },
    // overrides automatic reloading of previous fit results
    "force_fit": {
    	"option_default": false,
    	"option_choices":
    		[
    			true,
    			false
    		]
    }, 
     // fits all of the required pixels, false ignores the pixel fitting
    "fit_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    // fit pixels in a random order to give more accurate ETA
    "scramble_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    // if 'false', uses init guesses below on each pixel, 'true' uses best fit to ROI average
    "use_ROI_avg_fit_res_for_all_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
     // user must set this one: the functions that make up your fit model
    "fit_functions": {},

    // All parameters below can either have a range or a bound.
    // The code automatically detects this by the name of the dictionary key.x
    // range results in bounds of min = guess - range, max = guess + range
    // bounds directly gives these values

    // Position guess for lorentzian(in MHz)
    "pos_guess": {
    	"option_default": null
    },
    "pos_range": {
    	"option_default": 25
    },

    // Amplitude of peak (trough)
    "amp_guess": {
    	"option_default": -0.0015
    },

    "amp_bounds": {
    	"option_default": [-0.0100, -0.0003]
    },

    // Full width half maximum of the peaks
    "fwhm_guess": {
    	"option_default": -0.0015
    },

    "fwhm_bounds": {
    	"option_default": [5, 20]
    },

    // As above but for Gaussian
    "pos_gauss_guess": {
        "option_default": null
    },
    "pos_gauss_range": {
        "option_default": 25
    },
    "amp_gauss_guess": {
        "option_default": -0.0015
    },

    "amp_gauss_bounds": {
        "option_default": [-0.0100, -0.0003]
    },
    "fwhm_gauss_guess": {
        "option_default": -0.0015
    },

    "fwhm_gauss_bounds": {
        "option_default": [5, 20]
    },

    // linear function (background)
    "c_guess": {
    	"option_default": 1
    },
    "c_bounds": {
    	"option_default": [0.9995,1.0005]
    },

    "m_guess": {
    	"option_default": 0
    },
    "m_bounds": {
    	"option_default": [-1e-8, 1e-8]
    },

    // constant background
    "constant_guess": {
        "option_default": 1
    },
    "constant_bounds": {
        "option_default": [0.9995, 1.0005]
    },

    // circular function (haven't defined useful defaults)
    "rabi_freq_guess": {
        "option_default": null
    },
    "rabi_freq_bounds": {
        "option_default": [null, null]
    },
    "pos_circ_guess": {
        "option_default": null
    },
    "pos_circ_bounds": {
        "option_default": [null, null]
    },
    "amp_circ_guess": {
        "option_default": null
    },
    "amp_circ_bounds": {
        "option_default": [null, null]
    },

    // Other fit parameters (hyperfine functions)
    "pos_h14_guess": {
        "option_default": null
    },
    "pos_h15_guess": {
        "option_default": null
    },    
    "pos_h14_range": {
        "option_default": 25
    },
    "pos_h15_range": {
        "option_default": 25
    },

    "amp_h15_hyp_1_guess": {
    	"option_default": -0.015
    },
    "amp_h15_hyp_2_guess": {
        "option_default": -0.015
    },

    "amp_h15_hyp_1_bounds": {
    	"option_default": [-0.1, -0.001]
    },
    "amp_h15_hyp_2_bounds": {
    	"option_default": [-0.1, -0.001]
    },

    "amp_h14_hyp_1_guess": {
        "option_default": -0.015
    },
    "amp_h14_hyp_2_guess": {
        "option_default": -0.015
    },
    "amp_h14_hyp_3_guess": {
        "option_default": -0.015
    },

    "amp_h14_hyp_1_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "amp_h14_hyp_2_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "amp_h14_hyp_3_bounds": {
        "option_default": [-0.1, -0.001]
    },

    "fwhm_h15_hyp_1_guess": {
        "option_default": -0.015
    },
    "fwhm_h15_hyp_2_guess": {
        "option_default": -0.015
    },

    "fwhm_h15_hyp_1_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "fwhm_h15_hyp_2_bounds": {
        "option_default": [-0.1, -0.001]
    },

    "fwhm_h14_hyp_1_guess": {
        "option_default": -0.015
    },
    "fwhm_h14_hyp_2_guess": {
        "option_default": -0.015
    },
    "fwhm_h14_hyp_3_guess": {
        "option_default": -0.015
    },

    "fwhm_h14_hyp_1_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "fwhm_h14_hyp_2_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "fwhm_h14_hyp_3_bounds": {
        "option_default": [-0.1, -0.001]
    },

    "power_exp_guess": {
        "option_default": 0.7
    },
    "power_exp_bounds": {
        "option_default": [0.5, 1.0]
    },

    "charac_exp_t_guess": {
        "option_default": 1e-3
    },
    "charac_exp_t_bounds": {
        "option_default": [100e-6, 30e-3]
    },

    "amp_exp_guess": {
        "option_default": 0.07

    },
    "amp_exp_bounds": {
        "option_default": [0.001, 0.2]
    },


    // ========== scipy least means square options ===========
    // Method for scipy least means square,
    // lm (fast but doesn't use bounds),
    // trf (uses bounds and the most reliable fit method but can be very slow)
    // dogbox (uses bounds and is faster than trf)
    // ========== scipy least means square options ===========
    // Method for scipy least means square,
    // lm (fast but doesn't use bounds),
    // trf (uses bounds and the most reliable fit method but can be very slow)
    // dogbox (uses bounds and is faster than trf)
    "scipyfit_fit_method": {
        "option_default": "trf",
        "option_choices":
            [
                "lm",
                "trf",
                "dogbox"
            ]
    },
    // number of threads to *not* use for fitting
    "scipyfit_sub_threads": {
        "option_default": 0
    },
     // display progress bar during fitting
    "scipyfit_show_progressbar": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // uses an analytically determined Jacobian, This should be faster but hasn't been implemented 
    // for every function
    // - note it gives different fit results (should be more accurate than a finite-diff method)
    "scipyfit_use_analytic_jac": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // verbose fitting 0 = silent, 1 = term report, 2 display iterations
    "scipyfit_verbose_fitting": {
        "option_default": 0,
        "option_choices": 
            [
                0, 
                1,
                2
            ]
    },
    // The scheme ‘3-point’ is more accurate, but requires twice as many operations 
    // as ‘2-point’ (default).
    // The scheme ‘cs’ uses complex steps, and while potentially the most accurate, it is
    // applicable only when fun correctly handles complex inputs and can be analytically
    // continued to the complex plane.
    "scipyfit_fit_jac_acc":  {
        "option_default": "2-point",
        "option_choices": 
            [
                "2-point", 
                "3-point", 
                "cs"
            ]
    },
    // Tolerance settings, the exact condition depends on method used - see scipy documentation
    // Tolerance for termination by the change of the independent variables.
    "scipyfit_fit_gtol":  {
        "option_default": 1e-12
    },
    // Tolerance for termination by the norm of the gradient.
    "scipyfit_fit_xtol":  {
        "option_default": 1e-12
    },
    // Tolerance for termination by the change of the cost function.
    "scipyfit_fit_ftol": {
        "option_default": 1e-12
    },
    // Rescales the x by the units of the Jacobian (doesn't seem to make a difference)
    "scipyfit_scale_x": {
        "option_default": true,
        "options_choices":
            [
                true,
                false
            ]
    },
    // Determines the loss function. This in non trivial check the scipy documnetation
    "scipyfit_loss_fn": {
        "option_default": "linear",
        "option_choices": 
            [
                "linear", 
                "soft_l1", 
                "huber", 
                "cauchy",
                "arctan"
            ]
    },
    // ========== gpufit options ===========
    // Fit tolerance threshold
    // Setting a lower value for the tolerance results in more precise values for the fit 
    // parameters, but requires more fit iterations to reach convergence.
    // A typical value for the tolerance settings is between 1.0E-3 and 1.0E-6.
    "gpufit_tolerance": {
        "option_default": 1e-12
    },
    // Max number of iterations
    // The maximum number of fit iterations permitted. If the fit has not converged after this 
    // number of iterations, the fit returns with a status value indicating that the maximum 
    // number of iterations was reached.
    "gpufit_max_iterations": {
        "option_default": 25
    },
    // See https://gpufit.readthedocs.io/en/latest/fit_estimator_functions.html
    // default: least squares estimator
    // Use MLE (Maximum likelihood estimator) for data subject to Poisson statistics
    //  ->> Noise in the data is assumed to be purely Poissonian.
    "gpufit_estimator_id": {
        "option_default": "LSE",
        "option_choices": [
            "LSE",
            "MLE"
        ]
    },
	// ===========================================================================================
    // =============================== Plotting Parameters =======================================
	// ===========================================================================================
    "save_plots": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    "show_scalebar": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // for ROI/AOI PL plots only
    "annotate_image_regions": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    "save_fig_type":  {
    	"option_default": "png",
    	"option_choices":
    		[
    			"png",
    			"svg",
    			"pdf"
    		]
    },
    // choose colormap used for each 'type' of image
    "colormaps": {
        "option_default": {
            "param_images": "viridis",
            "PL_images": "Greys_r"
        }
    },
    // choose range of values mapped across to the colormap limits, for each 'type' of image
    // see options in QDMPy.plot._get_colormap_range
    "colormap_range_dicts": {
        "option_default": {
            "param_images": {
                "type": "min_max_symmetric_about_mean"
            },
            "PL_images": {
                "type": "min_max"
            }
        }
    },
    // extra parameters sent to matplotlib to define plotting stylesheet
    "mpl_rcparams": {
        "option_default": {
            "figure.figsize": [6.4, 4.8],
            "figure.dpi": 80,
            "lines.linewidth": 0.8,
            "lines.markersize" : 3,
            "xtick.labelsize": 10,
            "xtick.major.size": 4,
            "xtick.direction": "in",
            "ytick.labelsize" : 10,
            "ytick.direction": "in",
            "ytick.major.size": 4,
            "legend.fontsize": "small",
            "legend.loc": "lower left",
            "scalebar.location": "lower right",
            "scalebar.height_fraction": 0.015,
            "scalebar.box_alpha": 0.5,
            "scalebar.scale_loc": "top",
            "scalebar.sep": 1
        }
    },
    // colors to identify with each AOI region
    "AOI_colors": {
        "option_default": [
            "blue",
            "tab:brown",
            "purple",
            "darkslategrey",
            "magenta",
            "olive",
            "cyan"
        ]
    },
    "fit_backend_colors": {
        "option_default": {
            "scipyfit": {
                "roifit_linecolor": "mediumblue",
                "residual_linecolor": "black",
                "aoi_roi_fit_linecolor": "indigo",
                "aoi_best_fit_linecolor": "crimson"
            },
            "gpufit": {
                "roifit_linecolor": "cornflowerblue",
                "residual_linecolor": "dimgrey",
                "aoi_roi_fit_linecolor": "mediumpurple",
                "aoi_best_fit_linecolor": "coral"
            }
        }
    },
    // ===========================================================================================
    // Things set internally, allow to be anything {maybe place some contraints later}

    // was the options dict (after being read from .json) checked/cleaned?
    "cleaned": {},
    // pointer to system object
    "system": {},
    // flag that we used a reference
    "used_ref": {},
    // metadata dict read in
    "metadata": {},
    // for multiprocessing: # threads to use
    "threads": {},
    // did we automatically reload a previous fit result?
    "reloaded_prev_fit": {},
    // did we find a previous fit result?
    "found_prev_result": {},
    // directory to save results (directly in this dir: images)
    "output_dir": {},
    // directory within output to save data (output_dir/data_dir)
    "data_dir": {},
    // for the record, the parameters (and units) used in this fit model
    "fit_param_defn": {},
    // total (i.e. net) binning used
    "total_bin": {},
    // i.e. labview binning
    "original_bin": {},
    // modelID sent to gpufit (only used if gpufit selected as backend)
    "ModelID": {},
    // CUDA information, stored for the record
    "CUDA_version_runtime": {},
    "CUDA_version_driver": {},
    // time for gpu to fit image
    "fit_time_(s)": {}
}