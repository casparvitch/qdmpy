<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>QDMPy.fit_plots API documentation</title>
<meta name="description" content="This module holds functions for plotting initial processing images and fit results â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QDMPy.fit_plots</code></h1>
</header>
<section id="section-intro">
<p>This module holds functions for plotting initial processing images and fit results.</p>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="QDMPy.fit_plots.set_mpl_rcparams" href="#QDMPy.fit_plots.set_mpl_rcparams">set_mpl_rcparams()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_ROI_PL_image" href="#QDMPy.fit_plots.plot_ROI_PL_image">plot_ROI_PL_image()</a></code></li>
<li><code><a title="QDMPy.fit_plots.add_colorbar" href="#QDMPy.fit_plots.add_colorbar">add_colorbar()</a></code></li>
<li><code><a title="QDMPy.fit_plots.add_patch_square_centre" href="#QDMPy.fit_plots.add_patch_square_centre">add_patch_square_centre()</a></code></li>
<li><code><a title="QDMPy.fit_plots.add_patch_rect" href="#QDMPy.fit_plots.add_patch_rect">add_patch_rect()</a></code></li>
<li><code><a title="QDMPy.fit_plots.annotate_ROI_image" href="#QDMPy.fit_plots.annotate_ROI_image">annotate_ROI_image()</a></code></li>
<li><code><a title="QDMPy.fit_plots.annotate_AOI_image" href="#QDMPy.fit_plots.annotate_AOI_image">annotate_AOI_image()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_PL_images" href="#QDMPy.fit_plots.plot_AOI_PL_images">plot_AOI_PL_images()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_image" href="#QDMPy.fit_plots.plot_image">plot_image()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_image_on_ax" href="#QDMPy.fit_plots.plot_image_on_ax">plot_image_on_ax()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_ROI_avg_fit" href="#QDMPy.fit_plots.plot_ROI_avg_fit">plot_ROI_avg_fit()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_spectra" href="#QDMPy.fit_plots.plot_AOI_spectra">plot_AOI_spectra()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_spectra_fit" href="#QDMPy.fit_plots.plot_AOI_spectra_fit">plot_AOI_spectra_fit()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_param_image" href="#QDMPy.fit_plots.plot_param_image">plot_param_image()</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_param_images" href="#QDMPy.fit_plots.plot_param_images">plot_param_images()</a></code></li>
<li><code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max" href="#QDMPy.fit_plots.min_max">min_max()</a></code></li>
<li><code><a title="QDMPy.fit_plots.strict_range" href="#QDMPy.fit_plots.strict_range">strict_range()</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max_sym_mean" href="#QDMPy.fit_plots.min_max_sym_mean">min_max_sym_mean()</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max_sym_zero" href="#QDMPy.fit_plots.min_max_sym_zero">min_max_sym_zero()</a></code></li>
<li><code><a title="QDMPy.fit_plots.deviation_from_mean" href="#QDMPy.fit_plots.deviation_from_mean">deviation_from_mean()</a></code></li>
<li><code><a title="QDMPy.fit_plots.percentile" href="#QDMPy.fit_plots.percentile">percentile()</a></code></li>
<li><code><a title="QDMPy.fit_plots.percentile_sym_zero" href="#QDMPy.fit_plots.percentile_sym_zero">percentile_sym_zero()</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># - coding: utf-8 -*-
&#34;&#34;&#34;
This module holds functions for plotting initial processing images and fit results.

Functions
---------
 - `QDMPy.fit_plots.set_mpl_rcparams`
 - `QDMPy.fit_plots.plot_ROI_PL_image`
 - `QDMPy.fit_plots.add_colorbar`
 - `QDMPy.fit_plots.add_patch_square_centre`
 - `QDMPy.fit_plots.add_patch_rect`
 - `QDMPy.fit_plots.annotate_ROI_image`
 - `QDMPy.fit_plots.annotate_AOI_image`
 - `QDMPy.fit_plots.plot_AOI_PL_images`
 - `QDMPy.fit_plots.plot_image`
 - `QDMPy.fit_plots.plot_image_on_ax`
 - `QDMPy.fit_plots.plot_ROI_avg_fit`
 - `QDMPy.fit_plots.plot_AOI_spectra`
 - `QDMPy.fit_plots.plot_AOI_spectra_fit`
 - `QDMPy.fit_plots.plot_param_image`
 - `QDMPy.fit_plots.plot_param_images`
 - `QDMPy.fit_plots.get_colormap_range`
 - `QDMPy.fit_plots.min_max`
 - `QDMPy.fit_plots.strict_range`
 - `QDMPy.fit_plots.min_max_sym_mean`
 - `QDMPy.fit_plots.min_max_sym_zero`
 - `QDMPy.fit_plots.deviation_from_mean`
 - `QDMPy.fit_plots.percentile`
 - `QDMPy.fit_plots.percentile_sym_zero`

&#34;&#34;&#34;

# ============================================================================

__author__ = &#34;Sam Scholten&#34;

# ============================================================================

import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable, axes_size
from matplotlib_scalebar.scalebar import ScaleBar
import numpy as np
import matplotlib.patches as patches
import math
import warnings

# ============================================================================

import QDMPy.systems as systems
import QDMPy.fit_models as fit_models
import QDMPy.fitting as fitting
import QDMPy.data_loading as data_loading
import QDMPy.misc as misc

# ============================================================================

&#34;&#34;&#34;
NOTES

- MHz has been hardcoded in some places for the plots here, how to generalise?
&#34;&#34;&#34;

# ===========================================================================


def set_mpl_rcparams(options):
    &#34;&#34;&#34;Reads matplotlib-relevant parameters in options and used to define matplotlib rcParams&#34;&#34;&#34;
    for optn, val in options[&#34;mpl_rcparams&#34;].items():
        if type(val) == list:
            val = tuple(val)
        mpl.rcParams[optn] = val


# ===========================================================================


def plot_ROI_PL_image(options, PL_image):
    &#34;&#34;&#34;
    Plots full PL image with ROI region annotated.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image : np array, 2D.
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
        not cut down to ROI.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image)

    fig, ax = plot_image(options, PL_image, &#34;PL - ROI&#34;, c_map, c_range, &#34;Counts&#34;, None)

    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    if options[&#34;annotate_image_regions&#34;]:
        annotate_ROI_image(options, ax)

    # TODO implement elliptical/circular mask feature
    # --&gt; make object that can be passed around, saved/pickled after being tested etc.

    return fig


# ============================================================================


def add_colorbar(im, fig, ax, aspect=20, pad_fraction=1, **kwargs):
    &#34;&#34;&#34;
    Adds a colorbar to matplotlib axis

    Arguments
    ---------
    im : image as returned by ax.imshow

    fig : matplotlib Figure object

    ax : matplotlib Axis object


    Optional arguments
    ------------------
    aspect : int
        Reciprocal of aspect ratio passed to new colorbar axis width. Default: 20.

    pad_fraction : int
        Fraction of new colorbar axis width to pad from image. Default: 1.

    **kwargs : other keyword arguments
        Passed to fig.colorbar.

    Returns
    -------
    cbar : matplotlib colorbar object
    &#34;&#34;&#34;
    divider = make_axes_locatable(ax)
    width = axes_size.AxesY(ax, aspect=1.0 / aspect)
    pad = axes_size.Fraction(pad_fraction, width)
    cax = divider.append_axes(&#34;right&#34;, size=width, pad=pad)
    cbar = fig.colorbar(im, cax=cax, **kwargs)
    tick_locator = mpl.ticker.MaxNLocator(nbins=5)
    cbar.locator = tick_locator
    cbar.update_ticks()
    cbar.ax.get_yaxis().labelpad = 15
    cbar.ax.linewidth = 0.5
    return cbar


# ============================================================================


def add_patch_square_centre(ax, area_c, area_size, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Annotates square onto image figure.

    Arguments
    ---------
    ax : matplotlib Axis object

    area_c : int
        Location of centre of area you want to annotate.

    area_size : int
        Size of area you want to annotate.


    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    Returns
    -------
    Nothing.
    &#34;&#34;&#34;
    rect_corner = [int(area_c[0] - area_size / 2), int(area_c[1] - area_size / 2)]
    rect = patches.Rectangle(
        (rect_corner[0], rect_corner[1]),
        int(area_size),
        int(area_size),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        # Add label for the square
        ax.text(
            area_c[0] + 0.95 * area_size,  # label posn.: top right
            area_c[1],
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;center&#34;},
        )


# ============================================================================


def add_patch_rect(ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Same as `QDMPy.fit_plots.add_patch_square_centre` but a rectangular annotation.

    Arguments
    ---------
    ax : matplotlib Axis object

    rect_corner_x : int
        Location of top left corner of area you want to annotate, x component.

    rect_corner_y : int
        Location of top left corner of area you want to annotate, y component.

    size_x : int
        Size of area along x (horizontal axis) you want to annotate.
    size_y : int
        Size of area along y (vertical) axis you want to annotate.

    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    Returns
    -------
    Nothing.
    &#34;&#34;&#34;
    rect = patches.Rectangle(
        (rect_corner_x, rect_corner_y),
        int(size_x),
        int(size_y),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        ax.text(
            rect_corner_x + 0.95 * size_x,  # label posn.: top right
            rect_corner_y,
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;bottom&#34;},
        )


# ============================================================================


def annotate_ROI_image(options, ax):
    &#34;&#34;&#34;
    Annotates ROI onto a given Axis object. Generally used on a PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1
    if options[&#34;ROI&#34;] == &#34;Full&#34;:
        return None
    elif options[&#34;ROI&#34;] == &#34;Square&#34;:
        size = options[&#34;ROI_radius&#34;] * binning * 2
        corner = [
            options[&#34;ROI_centre&#34;][0] * binning - size / 2,
            options[&#34;ROI_centre&#34;][1] * binning - size / 2,
        ]

        add_patch_rect(ax, corner[0], corner[1], size, size, label=&#34;ROI&#34;, edgecolor=&#34;r&#34;)
    elif options[&#34;ROI&#34;] == &#34;Rectangle&#34;:
        start_x = options[&#34;ROI_centre&#34;][0] - options[&#34;ROI_rect_size&#34;][0] / 2
        start_y = options[&#34;ROI_centre&#34;][1] - options[&#34;ROI_rect_size&#34;][1] / 2
        size_x = options[&#34;ROI_rect_size&#34;][0]
        size_y = options[&#34;ROI_rect_size&#34;][1]

        add_patch_rect(ax, start_x, start_y, size_x, size_y, label=&#34;ROI&#34;, edgecolor=&#34;r&#34;)
    else:
        raise systems.OptionsError(
            &#34;ROI&#34;, options[&#34;ROI&#34;], options[&#34;system&#34;], custom_msg=&#34;Unknown ROI encountered.&#34;
        )


# ============================================================================


def annotate_AOI_image(options, ax):
    &#34;&#34;&#34;
    Annotates AOI onto a given Axis object. Generally used on PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1

    # annotate single pixel check
    corner = (options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1])
    size = 1
    add_patch_rect(
        ax, corner[0], corner[1], size, size, label=&#34;PX check&#34;, edgecolor=options[&#34;AOI_colors&#34;][0]
    )

    i = 0
    while True:
        i += 1
        try:
            centre = options[&#34;area_&#34; + str(i) + &#34;_centre&#34;]
            size = options[&#34;area_&#34; + str(i) + &#34;_halfsize&#34;]
            if centre is None or size is None:
                break
            centre *= binning
            size *= binning

            corner = [
                centre[0] - size,
                centre[1] - size,
            ]

            add_patch_rect(
                ax,
                corner[0],
                corner[1],
                size,
                size,
                label=&#34;AOI &#34; + str(i),
                edgecolor=options[&#34;AOI_colors&#34;][i],
            )
        except KeyError:
            break


# ============================================================================


def plot_AOI_PL_images(options, PL_image_ROI, AOIs):
    &#34;&#34;&#34;
    Plots PL image cut down to ROI, with annotated AOI regions.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image_ROI : np array, 2D.
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
        cut down to ROI.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    if AOIs == []:
        return None

    # need to convert back to um? TODO implement some sort of scalebar
    # pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image_ROI)

    fig, ax = plot_image(
        options,
        PL_image_ROI,
        &#34;PL - AOIs&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
        None,
    )
    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    if options[&#34;annotate_image_regions&#34;]:
        annotate_AOI_image(options, ax)

    # TODO implement elliptical/circular mask feature
    # --&gt; make object that can be passed around, saved/pickled after being tested etc.

    return fig


# ============================================================================


def plot_image(options, image_data, title, c_map, c_range, c_label, pixel_size):
    &#34;&#34;&#34;
    Plots an image given by image_data. Saves image_data as txt file as well as the figure.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    image_data : np array, 3D
        Data that is plot.

    title : str
        Title of figure, as well as name for save files

    c_map : str
        Colormap object used to map image_data values to a color.

    c_range : str
        Range of values in image_data to map to colors

    c_label : str
        Label for colormap axis

    pixel_size : str
        Size of each pixel in metres, used to define a scalebar.

    Returns
    -------
    fig : matplotlib Figure object

    ax : matplotlib Axis object
    &#34;&#34;&#34;

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_image_on_ax(
        fig, ax, options, image_data, title, c_map, c_range, c_label, pixel_size
    )

    np.savetxt(options[&#34;data_dir&#34;] / f&#34;{title}.txt&#34;, image_data)
    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (f&#34;{title}.&#34; + options[&#34;save_fig_type&#34;]))

    return fig, ax


# ============================================================================


def plot_image_on_ax(fig, ax, options, image_data, title, c_map, c_range, c_label, pixel_size):
    &#34;&#34;&#34;
    Plots an image given by image_data onto given figure and ax.

    Does not save any data.

    Arguments
    ---------
    fig : matplotlib Figure object

    ax : matplotlib Axis object

    options : dict
        Generic options dict holding all the user options.

    image_data : np array, 3D
        Data that is plot.

    title : str
        Title of figure, as well as name for save files

    c_map : str
        Colormap object used to map image_data values to a color.

    c_range : str
        Range of values in image_data to map to colors

    c_label : str
        Label for colormap axis

    pixel_size : str
        Size of each pixel in metres, used to define a scalebar.

    Returns
    -------
    fig : matplotlib Figure object

    ax : matplotlib Axis object
    &#34;&#34;&#34;

    im = ax.imshow(image_data, cmap=c_map, vmin=c_range[0], vmax=c_range[1])

    ax.set_title(title)
    ax.get_xaxis().set_ticks([])
    ax.get_yaxis().set_ticks([])

    cbar = add_colorbar(im, fig, ax)
    cbar.ax.set_ylabel(c_label, rotation=270)

    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    return fig, ax


# ============================================================================


def plot_ROI_avg_fit(options, roi_avg_fit_result):
    &#34;&#34;&#34;
    Plots fit of spectrum averaged across ROI, as well as corresponding residual values.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    roi_avg_fit_result : `QDMPy.fitting.FitResultROIAvg`
        `QDMPy.fitting.FitResultROIAvg` object, to pull fit_options from.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    res = roi_avg_fit_result

    fig = plt.figure(constrained_layout=False)  # constrained doesn&#39;t work well here
    # xstart, ystart, xend, yend [units are fraction of the image frame, from bottom left corner]
    spectrum_frame = fig.add_axes((0.1, 0.3, 0.8, 0.6))

    # ODMR spectrum
    spectrum_frame.plot(
        res.fit_sweep_vector,
        res.init_fit,
        linestyle=(0, (1, 1)),
        label=&#34;init guess&#34;,
        c=&#34;darkgreen&#34;,
    )
    spectrum_frame.plot(
        res.fit_sweep_vector,
        res.scipy_best_fit,
        linestyle=&#34;--&#34;,
        label=&#34;scipy best fit&#34;,
        c=&#34;mediumblue&#34;,
    )
    spectrum_frame.plot(
        res.sweep_list,
        res.pl_roi,
        label=&#34;raw data&#34;,
        ls=&#34; &#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;firebrick&#34;,
    )
    spectrum_frame.set_xticklabels([])  # remove from first frame
    spectrum_frame.legend()
    spectrum_frame.grid()
    spectrum_frame.set_ylabel(&#34;PL (a.u.)&#34;)

    # residual plot
    residual_frame = fig.add_axes((0.1, 0.1, 0.8, 0.2))
    res_xdata = res.sweep_list
    res_ydata = res.best_fit_pl_vals - res.pl_roi

    residual_frame.plot(
        res_xdata,
        res_ydata,
        label=&#34;residual&#34;,
        ls=&#34;dashed&#34;,
        c=&#34;black&#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;k&#34;,
    )
    residual_frame.legend()
    residual_frame.grid()
    residual_frame.set_xlabel(&#34;Sweep parameter&#34;)

    roi_avg_fit_result.savejson(&#34;ROI_avg_fit.json&#34;, options[&#34;data_dir&#34;])
    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;ROI_avg_fit.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_AOI_spectra(options, AOIs, sig, ref, sweep_list):
    &#34;&#34;&#34;
    Plots spectra from each AOI, as well as subtraction and division norms.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # pre-process data to plot
    sig_avgs = []
    ref_avgs = []
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nansum(np.nansum(sig[:, AOI[0], AOI[1]], 2), 1)
        sig_avg = sig_avg / np.max(sig_avg)
        ref_avg = np.nansum(np.nansum(ref[:, AOI[0], AOI[1]], 2), 1)
        ref_avg = ref_avg / np.max(ref_avg)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= len(AOIs)
    figsize[1] *= 2
    fig, axs = plt.subplots(
        2, len(AOIs), figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    for i, AOI in enumerate(AOIs):

        # plot sig
        axs[0, i].plot(
            sweep_list,
            sig_avgs[i],
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[0, i].plot(
            sweep_list,
            ref_avgs[i],
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[0, i].legend()
        axs[0, i].grid(True)
        axs[0, i].set_title(
            &#34;AOI &#34; + str(i + 1),
            fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i + 1]},
        )
        axs[0, i].set_ylabel(&#34;PL (a.u.)&#34;)

    linestyles = [
        &#34;--&#34;,
        &#34;-.&#34;,
        (0, (1, 1)),
        (0, (5, 10)),
        (0, (5, 5)),
        (0, (5, 1)),
        (0, (3, 10, 1, 10)),
        (0, (3, 5, 1, 5)),
        (0, (3, 1, 1, 1)),
        (0, (3, 5, 1, 5, 1, 5)),
        (0, (3, 10, 1, 10, 1, 10)),
        (0, (3, 1, 1, 1, 1, 1)),
    ]

    for i in range(len(AOIs)):
        # plot subtraction norm
        axs[1, 0].plot(
            sweep_list,
            1 + sig_avgs[i] - ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )
        axs[1, 0].legend()
        axs[1, 0].grid(True)
        axs[1, 0].set_title(&#34;Subtraction Normalisation&#34;)
        axs[1, 0].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 0].set_ylabel(&#34;PL (a.u.)&#34;)

        # plot division norm
        axs[1, 1].plot(
            sweep_list,
            sig_avgs[i] / ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )

        axs[1, 1].legend()
        axs[1, 1].grid(True)
        axs[1, 1].set_title(&#34;Division Normalisation&#34;)
        axs[1, 1].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 1].set_ylabel(&#34;PL (a.u.)&#34;)

    # delete axes that we didn&#39;t use
    for i in range(len(AOIs)):
        if i &lt; 2:  # we used these
            continue
        else:  # we didn&#39;t use these
            fig.delaxes(axs[1, i])

    output_dict = {}
    for i in range(len(AOIs)):
        output_dict[&#34;AOI_sig_avg&#34; + &#34;_&#34; + str(i + 1)] = sig_avgs[i]
        output_dict[&#34;AOI_ref_avg&#34; + &#34;_&#34; + str(i + 1)] = ref_avgs[i]

    misc.dict_to_json(output_dict, &#34;AOI_spectra.json&#34;, options[&#34;data_dir&#34;])

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra.&#34; + options[&#34;save_fig_type&#34;]))
    return fig


# ============================================================================


def plot_AOI_spectra_fit(
    options,
    sig,
    ref,
    sweep_list,
    AOIs,
    AOI_avg_best_fit_results_lst,
    roi_avg_fit_result,
    fit_model,
):
    &#34;&#34;&#34;
    Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
    pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
    average fit is plot against the fit of all of the others for comparison.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)


    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    AOI_avg_best_fit_results_lst : list
        List of fit_result.x arrays (i.e. list of best fit parameters)

    roi_avg_fit_result : `fitting.FitResultROIAvg`
        `QDMPy.fitting.FitResultROIAvg` object.

    fit_model : `fit_models.FitModel` object.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # rows:
    # ROI avg, single pixel, then each AOI
    # columns:
    # sig &amp; ref, sub &amp; div norm, fit -&gt; compared to ROI {raw, fit, ROI_avg_fit}

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 3  # number of columns
    # figsize[0] *= 2  # the above was too big
    figsize[1] *= 2 + len(AOIs)  # number of rows

    fig, axs = plt.subplots(
        2 + len(AOIs), 3, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    # pre-process raw data to plot
    sig_avgs = []
    ref_avgs = []
    # add roi data
    sz_h = int(options[&#34;metadata&#34;][&#34;AOIHeight&#34;] / options[&#34;additional_bins&#34;])
    sz_w = int(options[&#34;metadata&#34;][&#34;AOIWidth&#34;] / options[&#34;additional_bins&#34;])
    ROI = data_loading.define_ROI(options, sz_h, sz_w)
    roi_avg_sig = np.nansum(np.nansum(sig[:, ROI[0], ROI[1]], 2), 1)
    roi_avg_sig = roi_avg_sig / np.max(roi_avg_sig)
    roi_avg_ref = np.nansum(np.nansum(ref[:, ROI[0], ROI[1]], 2), 1)
    roi_avg_ref = roi_avg_ref / np.max(roi_avg_ref)
    sig_avgs.append(roi_avg_sig)
    ref_avgs.append(roi_avg_ref)
    # add single pixel check
    pixel_sig = sig[:, options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1]]
    pixel_sig = pixel_sig / np.max(pixel_sig)
    pixel_ref = ref[:, options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1]]
    pixel_ref = pixel_ref / np.max(pixel_ref)
    sig_avgs.append(pixel_sig)
    ref_avgs.append(pixel_ref)
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nansum(np.nansum(sig[:, AOI[0], AOI[1]], 2), 1)
        sig_avg = sig_avg / np.max(sig_avg)
        ref_avg = np.nansum(np.nansum(ref[:, AOI[0], AOI[1]], 2), 1)
        ref_avg = ref_avg / np.max(ref_avg)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    # now pre-process fit params
    fit_param_lst = []

    # roi avg
    fit_param_lst.append(roi_avg_fit_result.best_fit_result)

    # single pixel
    if not options[&#34;used_ref&#34;]:
        pixel_pl_ar = pixel_sig
    elif options[&#34;normalisation&#34;] == &#34;div&#34;:
        pixel_pl_ar = pixel_sig / pixel_ref
    elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
        pixel_pl_ar = pixel_sig - pixel_ref
    else:
        RuntimeError(f&#34;Not sure what normalisation value {options[&#39;normalisation&#39;]} is?&#34;)
    pixel_fit_params = fitting.fit_single_pixel(
        options, pixel_pl_ar, sweep_list, fit_model, roi_avg_fit_result
    )
    fit_param_lst.append(pixel_fit_params)

    # aois
    for AOI_best_fit_result in AOI_avg_best_fit_results_lst:
        fit_param_lst.append(AOI_best_fit_result)

    # plot sig, ref data as first column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):

        # plot sig
        axs[i, 0].plot(
            sweep_list,
            sig,
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[i, 0].plot(
            sweep_list,
            ref,
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[i, 0].legend()
        axs[i, 0].grid(True)
        if not i:
            axs[i, 0].set_title(&#34;ROI avg&#34;)
        elif i == 1:
            axs[i, 0].set_title(&#34;Single Pixel Check&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]})
        else:
            axs[i, 0].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]}
            )
        axs[i, 0].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 0].set_xlabel(&#34;Sweep parameter&#34;)

    # plot normalisation as second column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):
        axs[i, 1].plot(
            sweep_list,
            1 + sig - ref,
            label=&#34;subtraction&#34;,
            c=&#34;firebrick&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;lightcoral&#34;,
            mec=&#34;maroon&#34;,
        )
        axs[i, 1].plot(
            sweep_list,
            sig / ref,
            label=&#34;division&#34;,
            c=&#34;cadetblue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;powderblue&#34;,
            mec=&#34;darkslategrey&#34;,
        )

        axs[i, 1].legend()
        axs[i, 1].grid(True)
        if not i:
            axs[i, 1].set_title(&#34;ROI avg - Normalisation&#34;)
        elif i == 1:
            axs[i, 1].set_title(
                &#34;Single Pixel Check - Normalisation&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 1].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Normalisation&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )
        axs[i, 1].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 1].set_xlabel(
        &#34;Sweep parameter&#34;
    )  # this is meant to be less indentednormalisationnormalisation

    # plot fits as third column
    fit_sweep_vector = np.linspace(np.min(sweep_list), np.max(sweep_list), 10000)
    roi_avg_best_fit_ar = fit_model(roi_avg_fit_result.best_fit_result, fit_sweep_vector)

    for i, (fit_param_ar, sig, ref) in enumerate(zip(fit_param_lst, sig_avgs, ref_avgs)):
        if not options[&#34;used_ref&#34;]:
            sig_norm = sig
        elif options[&#34;normalisation&#34;] == &#34;div&#34;:
            sig_norm = sig / ref
        elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
            sig_norm = sig - ref

        best_fit_ar = fit_model(fit_param_ar, fit_sweep_vector)

        # raw data
        axs[i, 2].plot(
            sweep_list,
            sig_norm,
            label=&#34;raw data&#34;,
            ls=&#34;&#34;,
            marker=&#34;o&#34;,
            ms=3.5,
            mfc=&#34;goldenrod&#34;,
            mec=&#34;k&#34;,
        )
        # best fit
        axs[i, 2].plot(fit_sweep_vector, best_fit_ar, label=&#34;fit&#34;, ls=&#34;dashed&#34;, c=&#34;crimson&#34;)
        # roi avg fit (as comparison)
        if i:
            axs[i, 2].plot(
                fit_sweep_vector,
                roi_avg_best_fit_ar,
                label=&#34;ROI avg fit&#34;,
                c=&#34;indigo&#34;,
                ls=&#34;dashed&#34;,
            )
        if not i:
            axs[i, 2].set_title(&#34;ROI avg - Fit&#34;)
        elif i == 1:
            axs[i, 2].set_title(
                &#34;Single Pixel Check - Fit&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 2].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Fit&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )

        axs[i, 2].legend()
        axs[i, 2].grid(True)
        axs[i, 2].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 2].set_xlabel(&#34;Sweep parameter&#34;)  # this is meant to be less indented

    # currently not saving any of the data from this plot (not sure what the user would ever want)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra_fits.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_param_image(options, fit_model, pixel_fit_params, param_name, param_number=0):
    &#34;&#34;&#34;
    Plots an image corresponding to a single parameter in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `fit_models.FitModel` object.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;.


    Optional arguments
    ------------------
    param_number : int
        Which version of the parameter you want. I.e. there might be 8 independent parameters
        in the fit model called &#39;pos&#39;, each labeled &#39;pos_0&#39;, &#39;pos_1&#39; etc. Default: 0.


    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    image = pixel_fit_params[param_name + &#34;_&#34; + str(param_number)]
    c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image)
    c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

    fig, ax = plot_image(
        options,
        image,
        param_name + &#34;_&#34; + str(param_number),
        c_map,
        c_range,
        c_label,
        None,
    )
    return fig


# ============================================================================


def plot_param_images(options, fit_model, pixel_fit_params, param_name):
    &#34;&#34;&#34;
    Plots images for all independent versions of a single parameter type in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `fit_models.FitModel` object.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # plot 2 columns wide, as many rows as required

    # first get keys we need
    our_keys = []
    for key in pixel_fit_params:
        if key.startswith(param_name):
            our_keys.append(key)

    # this is an inner function so no one uses it elsewhere/protect namespace
    def param_sorter(param):
        param_name, num = param.split(&#34;_&#34;)
        return int(num)

    # sort based on number (just in case)
    our_keys.sort(key=param_sorter)

    if len(our_keys) == 1:
        # just one image, so plot normally
        fig = plot_param_image(options, fit_model, pixel_fit_params, param_name, 0)
    else:
        num_columns = 2
        num_rows = math.ceil(len(our_keys) / 2)

        figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
        figsize[0] *= num_columns
        figsize[1] *= num_rows

        fig, axs = plt.subplots(
            num_rows,
            num_columns,
            figsize=figsize,
            sharex=False,
            sharey=False,
            constrained_layout=True,
        )

        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]

        # plot 8-lorentzian peaks in a more helpful way (pairs: 0-7, 1-6, etc.)
        if len(our_keys) == 8 and &#34;lorentzian&#34; in options[&#34;fit_functions&#34;]:
            param_axis_iterator = zip([0, 7, 1, 6, 2, 5, 3, 4], axs.flatten())
        # otherwise plot in a more conventional order
        else:
            param_axis_iterator = enumerate(axs.flatten())

        for param_number, ax in param_axis_iterator:

            param_key = param_name + &#34;_&#34; + str(param_number)

            try:
                image_data = pixel_fit_params[param_key]
            except KeyError:
                # we have one too many axes (i.e. 7 params, 8 subplots), delete the axs
                fig.delaxes(ax)  # UNTESTED

            c_range = get_colormap_range(
                options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image_data
            )
            c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

            plot_image_on_ax(
                fig,
                ax,
                options,
                image_data,
                param_key,
                c_map,
                c_range,
                c_label,
                None,
            )

            np.savetxt(options[&#34;data_dir&#34;] / f&#34;{param_key}.txt&#34;, image_data)

        if options[&#34;save_plots&#34;]:
            fig.savefig(options[&#34;output_dir&#34;] / (param_name + &#34;.&#34; + options[&#34;save_fig_type&#34;]))


# ============================================================================


def get_colormap_range(c_range_dict, image):
    &#34;&#34;&#34;
    Produce a colormap range to plot image from, using the options in c_range_dict.

    Arguments
    ---------
    c_range_dict : dict
        dictionary with key &#39;values&#39;, used to accompany some of the options below,
        as well as a &#39;type&#39;, one of :
         - &#34;min_max&#34; : map between minimum and maximum values in image.
         - &#34;deviation_from_mean&#34; : requires c_range_dict[&#34;values&#34;] be a float
           between 0 and 1 &#39;dev&#39;. Maps between (1 - dev) * mean and (1 + dev) * mean.
         - &#34;min_max_symmetric_about_mean&#34; : map symmetrically about zero, capturing all values
           in image (default).
         - &#34;min_max_symmetric_about_zero&#34; : map symmetrically about zero, capturing all values
           in image.
         - &#34;percentile&#34; : requires c_range_dict[&#34;values&#34;] be a list of two numbers between 0 and
           100. Maps the range between those percentiles of the data.
         - &#34;percentile_symmetric_about_zero&#34; : requires c_range_dict[&#34;values&#34;] be a list of two
           numbers between 0 and 100. Maps symmetrically about zero, capturing all values between
           those percentile in the data (plus perhaps a bit more to ensure symmety)
         - &#34;strict_range&#34; : requires c_range_dict[&#34;values&#34;] be an int of float. Maps colors
           between the values given.
        as well as accompanying &#39;values&#39; key, used for some of the options below

    Returns
    -------
    c_range : list length 2
        i.e. [min value to map to a color, max value to map to a color]
    &#34;&#34;&#34;

    # mostly these are just checking that the input values are valid
    # pretty badly written, I apoligise (there&#39;s a reason it&#39;s hidden all the way down here...)

    warning_messages = {
        &#34;deviation_from_mean&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;deviation_from_mean&#39;, c_range_dict[&#39;vals&#39;] must be a float,
        between 0 and 1. Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;strict_range&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;strict_range&#39;, c_range_dict[&#39;vals&#39;] must be a a list of length 2,
        with elements that are floats or ints.
        Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;percentile&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;percentile&#39;, c_range_dict[&#39;vals&#39;] must be a list of length 2,
         with elements (preferably ints) between 0 and 100.
         Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;percentile_symmetric_about_zero&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;percentile&#39;, c_range_dict[&#39;vals&#39;] must be a list of length 2,
         with elements (preferably ints) between 0 and 100.
         Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
    }

    c_range_type = c_range_dict[&#34;type&#34;]
    if &#34;values&#34; in c_range_dict:
        c_range_values = c_range_dict[&#34;values&#34;]
    else:
        c_range_values = None

    range_calculator_dict = {
        &#34;min_max&#34;: min_max,
        &#34;deviation_from_mean&#34;: deviation_from_mean,
        &#34;min_max_symmetric_about_mean&#34;: min_max_sym_mean,
        &#34;min_max_symmetric_about_zero&#34;: min_max_sym_zero,
        &#34;percentile&#34;: percentile,
        &#34;percentile_symmetric_about_zero&#34;: percentile_sym_zero,
        &#34;strict_range&#34;: strict_range,
    }

    if c_range_type == &#34;strict_range&#34;:
        if (
            type(c_range_values) != list
            or len(c_range_values) != 2  # noqa: W503
            or (type(c_range_values[0]) != float and type(c_range_values[0]) != int)  # noqa: W503
            or (type(c_range_values[1]) != float and type(c_range_values[1]) != int)  # noqa: W503
            or c_range_values[0] &gt; c_range_values[1]  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)
    elif c_range_type == &#34;deviation_from_mean&#34;:
        if (
            (type(c_range_values) != float and type(c_range_values) != float)
            or c_range_values &lt; 0  # noqa: W503
            or c_range_values &gt; 1  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)

    elif c_range_type.startswith(&#34;percentile&#34;):
        if (
            type(c_range_values) != list
            or len(c_range_values) != 2  # noqa: W503
            or (type(c_range_values[0]) != float and type(c_range_values[0]) != int)  # noqa: W503
            or (type(c_range_values[1]) != float and type(c_range_values[1]) != int)  # noqa: W503
            or c_range_values[0] &lt; 0  # noqa: W503
            or c_range_values[0] &gt;= 100  # noqa: W503
            or c_range_values[1] &lt; 0  # noqa: W503
            or c_range_values[1] &gt;= 100  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)

    else:
        return range_calculator_dict[c_range_type](image, c_range_values)


# ============================


def min_max(image, c_range_values):
    &#34;&#34;&#34;
    Map between minimum and maximum values in image

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return [np.nanmin(image), np.nanmax(image)]


def strict_range(image, c_range_values):
    &#34;&#34;&#34;
    Map between c_range_values

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return list(c_range_values)


def min_max_sym_mean(image, c_range_values):
    &#34;&#34;&#34;
    Map symmetrically about mean, capturing all values in image.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    minimum = np.nanmin(image)
    maximum = np.nanmax(image)
    mean = np.mean(image)
    max_distance_from_mean = np.max([abs(maximum - mean), abs(minimum - mean)])
    return [mean - max_distance_from_mean, mean + max_distance_from_mean]


def min_max_sym_zero(image, c_range_values):
    &#34;&#34;&#34;
    Map symmetrically about zero, capturing all values in image.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    min_abs = np.abs(np.nanmin(image))
    max_abs = np.abs(np.nanmax(image))
    larger = np.nanmax([min_abs, max_abs])
    return [-larger, larger]


def deviation_from_mean(image, c_range_values):
    &#34;&#34;&#34;
    Map a (decimal) deviation from mean, i.e. between (1 - dev) * mean and (1 + dev) * mean

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return ([(1 - c_range_values) * np.mean(image), (1 + c_range_values) * np.mean(image)],)


def percentile(image, c_range_values):
    &#34;&#34;&#34;
    Maps the range between two percentiles of the data.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return [np.nanpercentile(image, c_range_values)]


def percentile_sym_zero(image, c_range_values):
    &#34;&#34;&#34;
    Maps the range between two percentiles of the data, but ensuring symmetry about zero

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    plow, phigh = np.nanpercentile(image, c_range_values)  # e.g. [10, 90]
    val = max(abs(plow), abs(phigh))
    return [-val, val]


# ============================================================================</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="QDMPy.fit_plots.add_colorbar"><code class="name flex">
<span>def <span class="ident">add_colorbar</span></span>(<span>im, fig, ax, aspect=20, pad_fraction=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a colorbar to matplotlib axis</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>im</code></strong> :&ensp;<code>image as returned by ax.imshow</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>aspect : int
Reciprocal of aspect ratio passed to new colorbar axis width. Default: 20.</p>
<p>pad_fraction : int
Fraction of new colorbar axis width to pad from image. Default: 1.</p>
<p>**kwargs : other keyword arguments
Passed to fig.colorbar.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cbar</code></strong> :&ensp;<code>matplotlib colorbar object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_colorbar(im, fig, ax, aspect=20, pad_fraction=1, **kwargs):
    &#34;&#34;&#34;
    Adds a colorbar to matplotlib axis

    Arguments
    ---------
    im : image as returned by ax.imshow

    fig : matplotlib Figure object

    ax : matplotlib Axis object


    Optional arguments
    ------------------
    aspect : int
        Reciprocal of aspect ratio passed to new colorbar axis width. Default: 20.

    pad_fraction : int
        Fraction of new colorbar axis width to pad from image. Default: 1.

    **kwargs : other keyword arguments
        Passed to fig.colorbar.

    Returns
    -------
    cbar : matplotlib colorbar object
    &#34;&#34;&#34;
    divider = make_axes_locatable(ax)
    width = axes_size.AxesY(ax, aspect=1.0 / aspect)
    pad = axes_size.Fraction(pad_fraction, width)
    cax = divider.append_axes(&#34;right&#34;, size=width, pad=pad)
    cbar = fig.colorbar(im, cax=cax, **kwargs)
    tick_locator = mpl.ticker.MaxNLocator(nbins=5)
    cbar.locator = tick_locator
    cbar.update_ticks()
    cbar.ax.get_yaxis().labelpad = 15
    cbar.ax.linewidth = 0.5
    return cbar</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.add_patch_rect"><code class="name flex">
<span>def <span class="ident">add_patch_rect</span></span>(<span>ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor='b')</span>
</code></dt>
<dd>
<div class="desc"><p>Same as <code><a title="QDMPy.fit_plots.add_patch_square_centre" href="#QDMPy.fit_plots.add_patch_square_centre">add_patch_square_centre()</a></code> but a rectangular annotation.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>rect_corner_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Location of top left corner of area you want to annotate, x component.</dd>
<dt><strong><code>rect_corner_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Location of top left corner of area you want to annotate, y component.</dd>
<dt><strong><code>size_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of area along x (horizontal axis) you want to annotate.</dd>
<dt><strong><code>size_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of area along y (vertical) axis you want to annotate.</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>label : str
Text to label annotated square with. Color is defined by edgecolor. Default: None.</p>
<p>edgecolor : str
Color of label and edge of annotation. Default: "b".</p>
<h2 id="returns">Returns</h2>
<p>Nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_patch_rect(ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Same as `QDMPy.fit_plots.add_patch_square_centre` but a rectangular annotation.

    Arguments
    ---------
    ax : matplotlib Axis object

    rect_corner_x : int
        Location of top left corner of area you want to annotate, x component.

    rect_corner_y : int
        Location of top left corner of area you want to annotate, y component.

    size_x : int
        Size of area along x (horizontal axis) you want to annotate.
    size_y : int
        Size of area along y (vertical) axis you want to annotate.

    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    Returns
    -------
    Nothing.
    &#34;&#34;&#34;
    rect = patches.Rectangle(
        (rect_corner_x, rect_corner_y),
        int(size_x),
        int(size_y),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        ax.text(
            rect_corner_x + 0.95 * size_x,  # label posn.: top right
            rect_corner_y,
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;bottom&#34;},
        )</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.add_patch_square_centre"><code class="name flex">
<span>def <span class="ident">add_patch_square_centre</span></span>(<span>ax, area_c, area_size, label=None, edgecolor='b')</span>
</code></dt>
<dd>
<div class="desc"><p>Annotates square onto image figure.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>area_c</code></strong> :&ensp;<code>int</code></dt>
<dd>Location of centre of area you want to annotate.</dd>
<dt><strong><code>area_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of area you want to annotate.</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>label : str
Text to label annotated square with. Color is defined by edgecolor. Default: None.</p>
<p>edgecolor : str
Color of label and edge of annotation. Default: "b".</p>
<h2 id="returns">Returns</h2>
<p>Nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_patch_square_centre(ax, area_c, area_size, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Annotates square onto image figure.

    Arguments
    ---------
    ax : matplotlib Axis object

    area_c : int
        Location of centre of area you want to annotate.

    area_size : int
        Size of area you want to annotate.


    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    Returns
    -------
    Nothing.
    &#34;&#34;&#34;
    rect_corner = [int(area_c[0] - area_size / 2), int(area_c[1] - area_size / 2)]
    rect = patches.Rectangle(
        (rect_corner[0], rect_corner[1]),
        int(area_size),
        int(area_size),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        # Add label for the square
        ax.text(
            area_c[0] + 0.95 * area_size,  # label posn.: top right
            area_c[1],
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;center&#34;},
        )</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.annotate_AOI_image"><code class="name flex">
<span>def <span class="ident">annotate_AOI_image</span></span>(<span>options, ax)</span>
</code></dt>
<dd>
<div class="desc"><p>Annotates AOI onto a given Axis object. Generally used on PL image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annotate_AOI_image(options, ax):
    &#34;&#34;&#34;
    Annotates AOI onto a given Axis object. Generally used on PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1

    # annotate single pixel check
    corner = (options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1])
    size = 1
    add_patch_rect(
        ax, corner[0], corner[1], size, size, label=&#34;PX check&#34;, edgecolor=options[&#34;AOI_colors&#34;][0]
    )

    i = 0
    while True:
        i += 1
        try:
            centre = options[&#34;area_&#34; + str(i) + &#34;_centre&#34;]
            size = options[&#34;area_&#34; + str(i) + &#34;_halfsize&#34;]
            if centre is None or size is None:
                break
            centre *= binning
            size *= binning

            corner = [
                centre[0] - size,
                centre[1] - size,
            ]

            add_patch_rect(
                ax,
                corner[0],
                corner[1],
                size,
                size,
                label=&#34;AOI &#34; + str(i),
                edgecolor=options[&#34;AOI_colors&#34;][i],
            )
        except KeyError:
            break</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.annotate_ROI_image"><code class="name flex">
<span>def <span class="ident">annotate_ROI_image</span></span>(<span>options, ax)</span>
</code></dt>
<dd>
<div class="desc"><p>Annotates ROI onto a given Axis object. Generally used on a PL image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annotate_ROI_image(options, ax):
    &#34;&#34;&#34;
    Annotates ROI onto a given Axis object. Generally used on a PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1
    if options[&#34;ROI&#34;] == &#34;Full&#34;:
        return None
    elif options[&#34;ROI&#34;] == &#34;Square&#34;:
        size = options[&#34;ROI_radius&#34;] * binning * 2
        corner = [
            options[&#34;ROI_centre&#34;][0] * binning - size / 2,
            options[&#34;ROI_centre&#34;][1] * binning - size / 2,
        ]

        add_patch_rect(ax, corner[0], corner[1], size, size, label=&#34;ROI&#34;, edgecolor=&#34;r&#34;)
    elif options[&#34;ROI&#34;] == &#34;Rectangle&#34;:
        start_x = options[&#34;ROI_centre&#34;][0] - options[&#34;ROI_rect_size&#34;][0] / 2
        start_y = options[&#34;ROI_centre&#34;][1] - options[&#34;ROI_rect_size&#34;][1] / 2
        size_x = options[&#34;ROI_rect_size&#34;][0]
        size_y = options[&#34;ROI_rect_size&#34;][1]

        add_patch_rect(ax, start_x, start_y, size_x, size_y, label=&#34;ROI&#34;, edgecolor=&#34;r&#34;)
    else:
        raise systems.OptionsError(
            &#34;ROI&#34;, options[&#34;ROI&#34;], options[&#34;system&#34;], custom_msg=&#34;Unknown ROI encountered.&#34;
        )</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.deviation_from_mean"><code class="name flex">
<span>def <span class="ident">deviation_from_mean</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Map a (decimal) deviation from mean, i.e. between (1 - dev) * mean and (1 + dev) * mean</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviation_from_mean(image, c_range_values):
    &#34;&#34;&#34;
    Map a (decimal) deviation from mean, i.e. between (1 - dev) * mean and (1 + dev) * mean

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return ([(1 - c_range_values) * np.mean(image), (1 + c_range_values) * np.mean(image)],)</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.get_colormap_range"><code class="name flex">
<span>def <span class="ident">get_colormap_range</span></span>(<span>c_range_dict, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a colormap range to plot image from, using the options in c_range_dict.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>c_range_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with key 'values', used to accompany some of the options below,
as well as a 'type', one of :
- "min_max" : map between minimum and maximum values in image.
- "deviation_from_mean" : requires c_range_dict["values"] be a float
between 0 and 1 'dev'. Maps between (1 - dev) * mean and (1 + dev) * mean.
- "min_max_symmetric_about_mean" : map symmetrically about zero, capturing all values
in image (default).
- "min_max_symmetric_about_zero" : map symmetrically about zero, capturing all values
in image.
- "percentile" : requires c_range_dict["values"] be a list of two numbers between 0 and
100. Maps the range between those percentiles of the data.
- "percentile_symmetric_about_zero" : requires c_range_dict["values"] be a list of two
numbers between 0 and 100. Maps symmetrically about zero, capturing all values between
those percentile in the data (plus perhaps a bit more to ensure symmety)
- "strict_range" : requires c_range_dict["values"] be an int of float. Maps colors
between the values given.
as well as accompanying 'values' key, used for some of the options below</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>c_range</code></strong> :&ensp;<code>list length 2</code></dt>
<dd>i.e. [min value to map to a color, max value to map to a color]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_colormap_range(c_range_dict, image):
    &#34;&#34;&#34;
    Produce a colormap range to plot image from, using the options in c_range_dict.

    Arguments
    ---------
    c_range_dict : dict
        dictionary with key &#39;values&#39;, used to accompany some of the options below,
        as well as a &#39;type&#39;, one of :
         - &#34;min_max&#34; : map between minimum and maximum values in image.
         - &#34;deviation_from_mean&#34; : requires c_range_dict[&#34;values&#34;] be a float
           between 0 and 1 &#39;dev&#39;. Maps between (1 - dev) * mean and (1 + dev) * mean.
         - &#34;min_max_symmetric_about_mean&#34; : map symmetrically about zero, capturing all values
           in image (default).
         - &#34;min_max_symmetric_about_zero&#34; : map symmetrically about zero, capturing all values
           in image.
         - &#34;percentile&#34; : requires c_range_dict[&#34;values&#34;] be a list of two numbers between 0 and
           100. Maps the range between those percentiles of the data.
         - &#34;percentile_symmetric_about_zero&#34; : requires c_range_dict[&#34;values&#34;] be a list of two
           numbers between 0 and 100. Maps symmetrically about zero, capturing all values between
           those percentile in the data (plus perhaps a bit more to ensure symmety)
         - &#34;strict_range&#34; : requires c_range_dict[&#34;values&#34;] be an int of float. Maps colors
           between the values given.
        as well as accompanying &#39;values&#39; key, used for some of the options below

    Returns
    -------
    c_range : list length 2
        i.e. [min value to map to a color, max value to map to a color]
    &#34;&#34;&#34;

    # mostly these are just checking that the input values are valid
    # pretty badly written, I apoligise (there&#39;s a reason it&#39;s hidden all the way down here...)

    warning_messages = {
        &#34;deviation_from_mean&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;deviation_from_mean&#39;, c_range_dict[&#39;vals&#39;] must be a float,
        between 0 and 1. Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;strict_range&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;strict_range&#39;, c_range_dict[&#39;vals&#39;] must be a a list of length 2,
        with elements that are floats or ints.
        Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;percentile&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;percentile&#39;, c_range_dict[&#39;vals&#39;] must be a list of length 2,
         with elements (preferably ints) between 0 and 100.
         Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
        &#34;percentile_symmetric_about_zero&#34;: &#34;&#34;&#34;Invalid c_range_dict[&#39;vals&#39;] encountered.
        For c_range type &#39;percentile&#39;, c_range_dict[&#39;vals&#39;] must be a list of length 2,
         with elements (preferably ints) between 0 and 100.
         Changing to &#39;min_max_symmetric_about_mean&#39; c_range.&#34;&#34;&#34;,
    }

    c_range_type = c_range_dict[&#34;type&#34;]
    if &#34;values&#34; in c_range_dict:
        c_range_values = c_range_dict[&#34;values&#34;]
    else:
        c_range_values = None

    range_calculator_dict = {
        &#34;min_max&#34;: min_max,
        &#34;deviation_from_mean&#34;: deviation_from_mean,
        &#34;min_max_symmetric_about_mean&#34;: min_max_sym_mean,
        &#34;min_max_symmetric_about_zero&#34;: min_max_sym_zero,
        &#34;percentile&#34;: percentile,
        &#34;percentile_symmetric_about_zero&#34;: percentile_sym_zero,
        &#34;strict_range&#34;: strict_range,
    }

    if c_range_type == &#34;strict_range&#34;:
        if (
            type(c_range_values) != list
            or len(c_range_values) != 2  # noqa: W503
            or (type(c_range_values[0]) != float and type(c_range_values[0]) != int)  # noqa: W503
            or (type(c_range_values[1]) != float and type(c_range_values[1]) != int)  # noqa: W503
            or c_range_values[0] &gt; c_range_values[1]  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)
    elif c_range_type == &#34;deviation_from_mean&#34;:
        if (
            (type(c_range_values) != float and type(c_range_values) != float)
            or c_range_values &lt; 0  # noqa: W503
            or c_range_values &gt; 1  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)

    elif c_range_type.startswith(&#34;percentile&#34;):
        if (
            type(c_range_values) != list
            or len(c_range_values) != 2  # noqa: W503
            or (type(c_range_values[0]) != float and type(c_range_values[0]) != int)  # noqa: W503
            or (type(c_range_values[1]) != float and type(c_range_values[1]) != int)  # noqa: W503
            or c_range_values[0] &lt; 0  # noqa: W503
            or c_range_values[0] &gt;= 100  # noqa: W503
            or c_range_values[1] &lt; 0  # noqa: W503
            or c_range_values[1] &gt;= 100  # noqa: W503
        ):
            warnings.warn(warning_messages[c_range_type])
            return min_max_sym_mean(image, c_range_values)

    else:
        return range_calculator_dict[c_range_type](image, c_range_values)</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.min_max"><code class="name flex">
<span>def <span class="ident">min_max</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Map between minimum and maximum values in image</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_max(image, c_range_values):
    &#34;&#34;&#34;
    Map between minimum and maximum values in image

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return [np.nanmin(image), np.nanmax(image)]</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.min_max_sym_mean"><code class="name flex">
<span>def <span class="ident">min_max_sym_mean</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Map symmetrically about mean, capturing all values in image.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_max_sym_mean(image, c_range_values):
    &#34;&#34;&#34;
    Map symmetrically about mean, capturing all values in image.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    minimum = np.nanmin(image)
    maximum = np.nanmax(image)
    mean = np.mean(image)
    max_distance_from_mean = np.max([abs(maximum - mean), abs(minimum - mean)])
    return [mean - max_distance_from_mean, mean + max_distance_from_mean]</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.min_max_sym_zero"><code class="name flex">
<span>def <span class="ident">min_max_sym_zero</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Map symmetrically about zero, capturing all values in image.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_max_sym_zero(image, c_range_values):
    &#34;&#34;&#34;
    Map symmetrically about zero, capturing all values in image.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    min_abs = np.abs(np.nanmin(image))
    max_abs = np.abs(np.nanmax(image))
    larger = np.nanmax([min_abs, max_abs])
    return [-larger, larger]</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.percentile"><code class="name flex">
<span>def <span class="ident">percentile</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps the range between two percentiles of the data.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def percentile(image, c_range_values):
    &#34;&#34;&#34;
    Maps the range between two percentiles of the data.

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return [np.nanpercentile(image, c_range_values)]</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.percentile_sym_zero"><code class="name flex">
<span>def <span class="ident">percentile_sym_zero</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps the range between two percentiles of the data, but ensuring symmetry about zero</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def percentile_sym_zero(image, c_range_values):
    &#34;&#34;&#34;
    Maps the range between two percentiles of the data, but ensuring symmetry about zero

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    plow, phigh = np.nanpercentile(image, c_range_values)  # e.g. [10, 90]
    val = max(abs(plow), abs(phigh))
    return [-val, val]</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_AOI_PL_images"><code class="name flex">
<span>def <span class="ident">plot_AOI_PL_images</span></span>(<span>options, PL_image_ROI, AOIs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots PL image cut down to ROI, with annotated AOI regions.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
</dl>
<p>PL_image_ROI : np array, 2D.
Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
cut down to ROI.</p>
<dl>
<dt><strong><code>AOIs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
that can be used to directly index into image to provide a view into just the AOI
part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
general we have more than one area of interest.
I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_PL_images(options, PL_image_ROI, AOIs):
    &#34;&#34;&#34;
    Plots PL image cut down to ROI, with annotated AOI regions.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image_ROI : np array, 2D.
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
        cut down to ROI.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    if AOIs == []:
        return None

    # need to convert back to um? TODO implement some sort of scalebar
    # pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image_ROI)

    fig, ax = plot_image(
        options,
        PL_image_ROI,
        &#34;PL - AOIs&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
        None,
    )
    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    if options[&#34;annotate_image_regions&#34;]:
        annotate_AOI_image(options, ax)

    # TODO implement elliptical/circular mask feature
    # --&gt; make object that can be passed around, saved/pickled after being tested etc.

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_AOI_spectra"><code class="name flex">
<span>def <span class="ident">plot_AOI_spectra</span></span>(<span>options, AOIs, sig, ref, sweep_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots spectra from each AOI, as well as subtraction and division norms.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>AOIs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
that can be used to directly index into image to provide a view into just the AOI
part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
general we have more than one area of interest.
I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, x, y]</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, x, y]</dd>
<dt><strong><code>sweep_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of sweep parameter values (with removed unwanted sweeps at start/end)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_spectra(options, AOIs, sig, ref, sweep_list):
    &#34;&#34;&#34;
    Plots spectra from each AOI, as well as subtraction and division norms.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # pre-process data to plot
    sig_avgs = []
    ref_avgs = []
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nansum(np.nansum(sig[:, AOI[0], AOI[1]], 2), 1)
        sig_avg = sig_avg / np.max(sig_avg)
        ref_avg = np.nansum(np.nansum(ref[:, AOI[0], AOI[1]], 2), 1)
        ref_avg = ref_avg / np.max(ref_avg)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= len(AOIs)
    figsize[1] *= 2
    fig, axs = plt.subplots(
        2, len(AOIs), figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    for i, AOI in enumerate(AOIs):

        # plot sig
        axs[0, i].plot(
            sweep_list,
            sig_avgs[i],
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[0, i].plot(
            sweep_list,
            ref_avgs[i],
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[0, i].legend()
        axs[0, i].grid(True)
        axs[0, i].set_title(
            &#34;AOI &#34; + str(i + 1),
            fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i + 1]},
        )
        axs[0, i].set_ylabel(&#34;PL (a.u.)&#34;)

    linestyles = [
        &#34;--&#34;,
        &#34;-.&#34;,
        (0, (1, 1)),
        (0, (5, 10)),
        (0, (5, 5)),
        (0, (5, 1)),
        (0, (3, 10, 1, 10)),
        (0, (3, 5, 1, 5)),
        (0, (3, 1, 1, 1)),
        (0, (3, 5, 1, 5, 1, 5)),
        (0, (3, 10, 1, 10, 1, 10)),
        (0, (3, 1, 1, 1, 1, 1)),
    ]

    for i in range(len(AOIs)):
        # plot subtraction norm
        axs[1, 0].plot(
            sweep_list,
            1 + sig_avgs[i] - ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )
        axs[1, 0].legend()
        axs[1, 0].grid(True)
        axs[1, 0].set_title(&#34;Subtraction Normalisation&#34;)
        axs[1, 0].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 0].set_ylabel(&#34;PL (a.u.)&#34;)

        # plot division norm
        axs[1, 1].plot(
            sweep_list,
            sig_avgs[i] / ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )

        axs[1, 1].legend()
        axs[1, 1].grid(True)
        axs[1, 1].set_title(&#34;Division Normalisation&#34;)
        axs[1, 1].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 1].set_ylabel(&#34;PL (a.u.)&#34;)

    # delete axes that we didn&#39;t use
    for i in range(len(AOIs)):
        if i &lt; 2:  # we used these
            continue
        else:  # we didn&#39;t use these
            fig.delaxes(axs[1, i])

    output_dict = {}
    for i in range(len(AOIs)):
        output_dict[&#34;AOI_sig_avg&#34; + &#34;_&#34; + str(i + 1)] = sig_avgs[i]
        output_dict[&#34;AOI_ref_avg&#34; + &#34;_&#34; + str(i + 1)] = ref_avgs[i]

    misc.dict_to_json(output_dict, &#34;AOI_spectra.json&#34;, options[&#34;data_dir&#34;])

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra.&#34; + options[&#34;save_fig_type&#34;]))
    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_AOI_spectra_fit"><code class="name flex">
<span>def <span class="ident">plot_AOI_spectra_fit</span></span>(<span>options, sig, ref, sweep_list, AOIs, AOI_avg_best_fit_results_lst, roi_avg_fit_result, fit_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
average fit is plot against the fit of all of the others for comparison.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, x, y]</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, x, y]</dd>
<dt><strong><code>sweep_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of sweep parameter values (with removed unwanted sweeps at start/end)</dd>
<dt><strong><code>AOIs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
that can be used to directly index into image to provide a view into just the AOI
part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
general we have more than one area of interest.
I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]</dd>
<dt><strong><code>AOI_avg_best_fit_results_lst</code></strong> :&ensp;<code>list</code></dt>
<dd>List of fit_result.x arrays (i.e. list of best fit parameters)</dd>
<dt><strong><code>roi_avg_fit_result</code></strong> :&ensp;<code>fitting.FitResultROIAvg</code></dt>
<dd><code><a title="QDMPy.fitting.FitResultROIAvg" href="fitting.html#QDMPy.fitting.FitResultROIAvg">FitResultROIAvg</a></code> object.</dd>
</dl>
<p>fit_model : <code>fit_models.FitModel</code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_spectra_fit(
    options,
    sig,
    ref,
    sweep_list,
    AOIs,
    AOI_avg_best_fit_results_lst,
    roi_avg_fit_result,
    fit_model,
):
    &#34;&#34;&#34;
    Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
    pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
    average fit is plot against the fit of all of the others for comparison.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, x, y]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)


    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    AOI_avg_best_fit_results_lst : list
        List of fit_result.x arrays (i.e. list of best fit parameters)

    roi_avg_fit_result : `fitting.FitResultROIAvg`
        `QDMPy.fitting.FitResultROIAvg` object.

    fit_model : `fit_models.FitModel` object.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # rows:
    # ROI avg, single pixel, then each AOI
    # columns:
    # sig &amp; ref, sub &amp; div norm, fit -&gt; compared to ROI {raw, fit, ROI_avg_fit}

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 3  # number of columns
    # figsize[0] *= 2  # the above was too big
    figsize[1] *= 2 + len(AOIs)  # number of rows

    fig, axs = plt.subplots(
        2 + len(AOIs), 3, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    # pre-process raw data to plot
    sig_avgs = []
    ref_avgs = []
    # add roi data
    sz_h = int(options[&#34;metadata&#34;][&#34;AOIHeight&#34;] / options[&#34;additional_bins&#34;])
    sz_w = int(options[&#34;metadata&#34;][&#34;AOIWidth&#34;] / options[&#34;additional_bins&#34;])
    ROI = data_loading.define_ROI(options, sz_h, sz_w)
    roi_avg_sig = np.nansum(np.nansum(sig[:, ROI[0], ROI[1]], 2), 1)
    roi_avg_sig = roi_avg_sig / np.max(roi_avg_sig)
    roi_avg_ref = np.nansum(np.nansum(ref[:, ROI[0], ROI[1]], 2), 1)
    roi_avg_ref = roi_avg_ref / np.max(roi_avg_ref)
    sig_avgs.append(roi_avg_sig)
    ref_avgs.append(roi_avg_ref)
    # add single pixel check
    pixel_sig = sig[:, options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1]]
    pixel_sig = pixel_sig / np.max(pixel_sig)
    pixel_ref = ref[:, options[&#34;single_pixel_check&#34;][0], options[&#34;single_pixel_check&#34;][1]]
    pixel_ref = pixel_ref / np.max(pixel_ref)
    sig_avgs.append(pixel_sig)
    ref_avgs.append(pixel_ref)
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nansum(np.nansum(sig[:, AOI[0], AOI[1]], 2), 1)
        sig_avg = sig_avg / np.max(sig_avg)
        ref_avg = np.nansum(np.nansum(ref[:, AOI[0], AOI[1]], 2), 1)
        ref_avg = ref_avg / np.max(ref_avg)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    # now pre-process fit params
    fit_param_lst = []

    # roi avg
    fit_param_lst.append(roi_avg_fit_result.best_fit_result)

    # single pixel
    if not options[&#34;used_ref&#34;]:
        pixel_pl_ar = pixel_sig
    elif options[&#34;normalisation&#34;] == &#34;div&#34;:
        pixel_pl_ar = pixel_sig / pixel_ref
    elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
        pixel_pl_ar = pixel_sig - pixel_ref
    else:
        RuntimeError(f&#34;Not sure what normalisation value {options[&#39;normalisation&#39;]} is?&#34;)
    pixel_fit_params = fitting.fit_single_pixel(
        options, pixel_pl_ar, sweep_list, fit_model, roi_avg_fit_result
    )
    fit_param_lst.append(pixel_fit_params)

    # aois
    for AOI_best_fit_result in AOI_avg_best_fit_results_lst:
        fit_param_lst.append(AOI_best_fit_result)

    # plot sig, ref data as first column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):

        # plot sig
        axs[i, 0].plot(
            sweep_list,
            sig,
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[i, 0].plot(
            sweep_list,
            ref,
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[i, 0].legend()
        axs[i, 0].grid(True)
        if not i:
            axs[i, 0].set_title(&#34;ROI avg&#34;)
        elif i == 1:
            axs[i, 0].set_title(&#34;Single Pixel Check&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]})
        else:
            axs[i, 0].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]}
            )
        axs[i, 0].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 0].set_xlabel(&#34;Sweep parameter&#34;)

    # plot normalisation as second column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):
        axs[i, 1].plot(
            sweep_list,
            1 + sig - ref,
            label=&#34;subtraction&#34;,
            c=&#34;firebrick&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;lightcoral&#34;,
            mec=&#34;maroon&#34;,
        )
        axs[i, 1].plot(
            sweep_list,
            sig / ref,
            label=&#34;division&#34;,
            c=&#34;cadetblue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;powderblue&#34;,
            mec=&#34;darkslategrey&#34;,
        )

        axs[i, 1].legend()
        axs[i, 1].grid(True)
        if not i:
            axs[i, 1].set_title(&#34;ROI avg - Normalisation&#34;)
        elif i == 1:
            axs[i, 1].set_title(
                &#34;Single Pixel Check - Normalisation&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 1].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Normalisation&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )
        axs[i, 1].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 1].set_xlabel(
        &#34;Sweep parameter&#34;
    )  # this is meant to be less indentednormalisationnormalisation

    # plot fits as third column
    fit_sweep_vector = np.linspace(np.min(sweep_list), np.max(sweep_list), 10000)
    roi_avg_best_fit_ar = fit_model(roi_avg_fit_result.best_fit_result, fit_sweep_vector)

    for i, (fit_param_ar, sig, ref) in enumerate(zip(fit_param_lst, sig_avgs, ref_avgs)):
        if not options[&#34;used_ref&#34;]:
            sig_norm = sig
        elif options[&#34;normalisation&#34;] == &#34;div&#34;:
            sig_norm = sig / ref
        elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
            sig_norm = sig - ref

        best_fit_ar = fit_model(fit_param_ar, fit_sweep_vector)

        # raw data
        axs[i, 2].plot(
            sweep_list,
            sig_norm,
            label=&#34;raw data&#34;,
            ls=&#34;&#34;,
            marker=&#34;o&#34;,
            ms=3.5,
            mfc=&#34;goldenrod&#34;,
            mec=&#34;k&#34;,
        )
        # best fit
        axs[i, 2].plot(fit_sweep_vector, best_fit_ar, label=&#34;fit&#34;, ls=&#34;dashed&#34;, c=&#34;crimson&#34;)
        # roi avg fit (as comparison)
        if i:
            axs[i, 2].plot(
                fit_sweep_vector,
                roi_avg_best_fit_ar,
                label=&#34;ROI avg fit&#34;,
                c=&#34;indigo&#34;,
                ls=&#34;dashed&#34;,
            )
        if not i:
            axs[i, 2].set_title(&#34;ROI avg - Fit&#34;)
        elif i == 1:
            axs[i, 2].set_title(
                &#34;Single Pixel Check - Fit&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 2].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Fit&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )

        axs[i, 2].legend()
        axs[i, 2].grid(True)
        axs[i, 2].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 2].set_xlabel(&#34;Sweep parameter&#34;)  # this is meant to be less indented

    # currently not saving any of the data from this plot (not sure what the user would ever want)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra_fits.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_ROI_PL_image"><code class="name flex">
<span>def <span class="ident">plot_ROI_PL_image</span></span>(<span>options, PL_image)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots full PL image with ROI region annotated.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
</dl>
<p>PL_image : np array, 2D.
Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
not cut down to ROI.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ROI_PL_image(options, PL_image):
    &#34;&#34;&#34;
    Plots full PL image with ROI region annotated.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image : np array, 2D.
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
        not cut down to ROI.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image)

    fig, ax = plot_image(options, PL_image, &#34;PL - ROI&#34;, c_map, c_range, &#34;Counts&#34;, None)

    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    if options[&#34;annotate_image_regions&#34;]:
        annotate_ROI_image(options, ax)

    # TODO implement elliptical/circular mask feature
    # --&gt; make object that can be passed around, saved/pickled after being tested etc.

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_ROI_avg_fit"><code class="name flex">
<span>def <span class="ident">plot_ROI_avg_fit</span></span>(<span>options, roi_avg_fit_result)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots fit of spectrum averaged across ROI, as well as corresponding residual values.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>roi_avg_fit_result</code></strong> :&ensp;<code><a title="QDMPy.fitting.FitResultROIAvg" href="fitting.html#QDMPy.fitting.FitResultROIAvg">FitResultROIAvg</a></code></dt>
<dd><code><a title="QDMPy.fitting.FitResultROIAvg" href="fitting.html#QDMPy.fitting.FitResultROIAvg">FitResultROIAvg</a></code> object, to pull fit_options from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ROI_avg_fit(options, roi_avg_fit_result):
    &#34;&#34;&#34;
    Plots fit of spectrum averaged across ROI, as well as corresponding residual values.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    roi_avg_fit_result : `QDMPy.fitting.FitResultROIAvg`
        `QDMPy.fitting.FitResultROIAvg` object, to pull fit_options from.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    res = roi_avg_fit_result

    fig = plt.figure(constrained_layout=False)  # constrained doesn&#39;t work well here
    # xstart, ystart, xend, yend [units are fraction of the image frame, from bottom left corner]
    spectrum_frame = fig.add_axes((0.1, 0.3, 0.8, 0.6))

    # ODMR spectrum
    spectrum_frame.plot(
        res.fit_sweep_vector,
        res.init_fit,
        linestyle=(0, (1, 1)),
        label=&#34;init guess&#34;,
        c=&#34;darkgreen&#34;,
    )
    spectrum_frame.plot(
        res.fit_sweep_vector,
        res.scipy_best_fit,
        linestyle=&#34;--&#34;,
        label=&#34;scipy best fit&#34;,
        c=&#34;mediumblue&#34;,
    )
    spectrum_frame.plot(
        res.sweep_list,
        res.pl_roi,
        label=&#34;raw data&#34;,
        ls=&#34; &#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;firebrick&#34;,
    )
    spectrum_frame.set_xticklabels([])  # remove from first frame
    spectrum_frame.legend()
    spectrum_frame.grid()
    spectrum_frame.set_ylabel(&#34;PL (a.u.)&#34;)

    # residual plot
    residual_frame = fig.add_axes((0.1, 0.1, 0.8, 0.2))
    res_xdata = res.sweep_list
    res_ydata = res.best_fit_pl_vals - res.pl_roi

    residual_frame.plot(
        res_xdata,
        res_ydata,
        label=&#34;residual&#34;,
        ls=&#34;dashed&#34;,
        c=&#34;black&#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;k&#34;,
    )
    residual_frame.legend()
    residual_frame.grid()
    residual_frame.set_xlabel(&#34;Sweep parameter&#34;)

    roi_avg_fit_result.savejson(&#34;ROI_avg_fit.json&#34;, options[&#34;data_dir&#34;])
    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;ROI_avg_fit.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_image"><code class="name flex">
<span>def <span class="ident">plot_image</span></span>(<span>options, image_data, title, c_map, c_range, c_label, pixel_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots an image given by image_data. Saves image_data as txt file as well as the figure.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>image_data</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Data that is plot.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title of figure, as well as name for save files</dd>
<dt><strong><code>c_map</code></strong> :&ensp;<code>str</code></dt>
<dd>Colormap object used to map image_data values to a color.</dd>
<dt><strong><code>c_range</code></strong> :&ensp;<code>str</code></dt>
<dd>Range of values in image_data to map to colors</dd>
<dt><strong><code>c_label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label for colormap axis</dd>
<dt><strong><code>pixel_size</code></strong> :&ensp;<code>str</code></dt>
<dd>Size of each pixel in metres, used to define a scalebar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_image(options, image_data, title, c_map, c_range, c_label, pixel_size):
    &#34;&#34;&#34;
    Plots an image given by image_data. Saves image_data as txt file as well as the figure.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    image_data : np array, 3D
        Data that is plot.

    title : str
        Title of figure, as well as name for save files

    c_map : str
        Colormap object used to map image_data values to a color.

    c_range : str
        Range of values in image_data to map to colors

    c_label : str
        Label for colormap axis

    pixel_size : str
        Size of each pixel in metres, used to define a scalebar.

    Returns
    -------
    fig : matplotlib Figure object

    ax : matplotlib Axis object
    &#34;&#34;&#34;

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_image_on_ax(
        fig, ax, options, image_data, title, c_map, c_range, c_label, pixel_size
    )

    np.savetxt(options[&#34;data_dir&#34;] / f&#34;{title}.txt&#34;, image_data)
    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (f&#34;{title}.&#34; + options[&#34;save_fig_type&#34;]))

    return fig, ax</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_image_on_ax"><code class="name flex">
<span>def <span class="ident">plot_image_on_ax</span></span>(<span>fig, ax, options, image_data, title, c_map, c_range, c_label, pixel_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots an image given by image_data onto given figure and ax.</p>
<p>Does not save any data.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>image_data</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Data that is plot.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title of figure, as well as name for save files</dd>
<dt><strong><code>c_map</code></strong> :&ensp;<code>str</code></dt>
<dd>Colormap object used to map image_data values to a color.</dd>
<dt><strong><code>c_range</code></strong> :&ensp;<code>str</code></dt>
<dd>Range of values in image_data to map to colors</dd>
<dt><strong><code>c_label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label for colormap axis</dd>
<dt><strong><code>pixel_size</code></strong> :&ensp;<code>str</code></dt>
<dd>Size of each pixel in metres, used to define a scalebar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_image_on_ax(fig, ax, options, image_data, title, c_map, c_range, c_label, pixel_size):
    &#34;&#34;&#34;
    Plots an image given by image_data onto given figure and ax.

    Does not save any data.

    Arguments
    ---------
    fig : matplotlib Figure object

    ax : matplotlib Axis object

    options : dict
        Generic options dict holding all the user options.

    image_data : np array, 3D
        Data that is plot.

    title : str
        Title of figure, as well as name for save files

    c_map : str
        Colormap object used to map image_data values to a color.

    c_range : str
        Range of values in image_data to map to colors

    c_label : str
        Label for colormap axis

    pixel_size : str
        Size of each pixel in metres, used to define a scalebar.

    Returns
    -------
    fig : matplotlib Figure object

    ax : matplotlib Axis object
    &#34;&#34;&#34;

    im = ax.imshow(image_data, cmap=c_map, vmin=c_range[0], vmax=c_range[1])

    ax.set_title(title)
    ax.get_xaxis().set_ticks([])
    ax.get_yaxis().set_ticks([])

    cbar = add_colorbar(im, fig, ax)
    cbar.ax.set_ylabel(c_label, rotation=270)

    if options[&#34;show_scalebar&#34;]:
        pixel_size = options[&#34;system&#34;].get_raw_pixel_size() * options[&#34;total_bin&#34;]
        scalebar = ScaleBar(pixel_size)
        ax.add_artist(scalebar)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_param_image"><code class="name flex">
<span>def <span class="ident">plot_param_image</span></span>(<span>options, fit_model, pixel_fit_params, param_name, param_number=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots an image corresponding to a single parameter in pixel_fit_params.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
</dl>
<p>fit_model : <code>fit_models.FitModel</code> object.</p>
<dl>
<dt><strong><code>pixel_fit_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary, key: param_keys, val: image (2D) of param values across FOV.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of parameter you want to plot, e.g. 'fwhm'.</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>param_number : int
Which version of the parameter you want. I.e. there might be 8 independent parameters
in the fit model called 'pos', each labeled 'pos_0', 'pos_1' etc. Default: 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_param_image(options, fit_model, pixel_fit_params, param_name, param_number=0):
    &#34;&#34;&#34;
    Plots an image corresponding to a single parameter in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `fit_models.FitModel` object.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;.


    Optional arguments
    ------------------
    param_number : int
        Which version of the parameter you want. I.e. there might be 8 independent parameters
        in the fit model called &#39;pos&#39;, each labeled &#39;pos_0&#39;, &#39;pos_1&#39; etc. Default: 0.


    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    image = pixel_fit_params[param_name + &#34;_&#34; + str(param_number)]
    c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]
    c_range = get_colormap_range(options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image)
    c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

    fig, ax = plot_image(
        options,
        image,
        param_name + &#34;_&#34; + str(param_number),
        c_map,
        c_range,
        c_label,
        None,
    )
    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.plot_param_images"><code class="name flex">
<span>def <span class="ident">plot_param_images</span></span>(<span>options, fit_model, pixel_fit_params, param_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots images for all independent versions of a single parameter type in pixel_fit_params.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
</dl>
<p>fit_model : <code>fit_models.FitModel</code> object.</p>
<dl>
<dt><strong><code>pixel_fit_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary, key: param_keys, val: image (2D) of param values across FOV.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of parameter you want to plot, e.g. 'fwhm'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_param_images(options, fit_model, pixel_fit_params, param_name):
    &#34;&#34;&#34;
    Plots images for all independent versions of a single parameter type in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `fit_models.FitModel` object.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # plot 2 columns wide, as many rows as required

    # first get keys we need
    our_keys = []
    for key in pixel_fit_params:
        if key.startswith(param_name):
            our_keys.append(key)

    # this is an inner function so no one uses it elsewhere/protect namespace
    def param_sorter(param):
        param_name, num = param.split(&#34;_&#34;)
        return int(num)

    # sort based on number (just in case)
    our_keys.sort(key=param_sorter)

    if len(our_keys) == 1:
        # just one image, so plot normally
        fig = plot_param_image(options, fit_model, pixel_fit_params, param_name, 0)
    else:
        num_columns = 2
        num_rows = math.ceil(len(our_keys) / 2)

        figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
        figsize[0] *= num_columns
        figsize[1] *= num_rows

        fig, axs = plt.subplots(
            num_rows,
            num_columns,
            figsize=figsize,
            sharex=False,
            sharey=False,
            constrained_layout=True,
        )

        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]

        # plot 8-lorentzian peaks in a more helpful way (pairs: 0-7, 1-6, etc.)
        if len(our_keys) == 8 and &#34;lorentzian&#34; in options[&#34;fit_functions&#34;]:
            param_axis_iterator = zip([0, 7, 1, 6, 2, 5, 3, 4], axs.flatten())
        # otherwise plot in a more conventional order
        else:
            param_axis_iterator = enumerate(axs.flatten())

        for param_number, ax in param_axis_iterator:

            param_key = param_name + &#34;_&#34; + str(param_number)

            try:
                image_data = pixel_fit_params[param_key]
            except KeyError:
                # we have one too many axes (i.e. 7 params, 8 subplots), delete the axs
                fig.delaxes(ax)  # UNTESTED

            c_range = get_colormap_range(
                options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image_data
            )
            c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

            plot_image_on_ax(
                fig,
                ax,
                options,
                image_data,
                param_key,
                c_map,
                c_range,
                c_label,
                None,
            )

            np.savetxt(options[&#34;data_dir&#34;] / f&#34;{param_key}.txt&#34;, image_data)

        if options[&#34;save_plots&#34;]:
            fig.savefig(options[&#34;output_dir&#34;] / (param_name + &#34;.&#34; + options[&#34;save_fig_type&#34;]))</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.set_mpl_rcparams"><code class="name flex">
<span>def <span class="ident">set_mpl_rcparams</span></span>(<span>options)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads matplotlib-relevant parameters in options and used to define matplotlib rcParams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mpl_rcparams(options):
    &#34;&#34;&#34;Reads matplotlib-relevant parameters in options and used to define matplotlib rcParams&#34;&#34;&#34;
    for optn, val in options[&#34;mpl_rcparams&#34;].items():
        if type(val) == list:
            val = tuple(val)
        mpl.rcParams[optn] = val</code></pre>
</details>
</dd>
<dt id="QDMPy.fit_plots.strict_range"><code class="name flex">
<span>def <span class="ident">strict_range</span></span>(<span>image, c_range_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Map between c_range_values</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>image data being shown as ax.imshow</dd>
<dt><strong><code>c_range_values</code></strong> :&ensp;<code>unknown (depends on user settings)</code></dt>
<dd>See <code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strict_range(image, c_range_values):
    &#34;&#34;&#34;
    Map between c_range_values

    Arguments
    ---------
    image : np array, 3D
        image data being shown as ax.imshow

    c_range_values : unknown (depends on user settings)
        See `QDMPy.fit_plots.get_colormap_range`
    &#34;&#34;&#34;
    return list(c_range_values)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#functions">Functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QDMPy" href="index.html">QDMPy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="QDMPy.fit_plots.add_colorbar" href="#QDMPy.fit_plots.add_colorbar">add_colorbar</a></code></li>
<li><code><a title="QDMPy.fit_plots.add_patch_rect" href="#QDMPy.fit_plots.add_patch_rect">add_patch_rect</a></code></li>
<li><code><a title="QDMPy.fit_plots.add_patch_square_centre" href="#QDMPy.fit_plots.add_patch_square_centre">add_patch_square_centre</a></code></li>
<li><code><a title="QDMPy.fit_plots.annotate_AOI_image" href="#QDMPy.fit_plots.annotate_AOI_image">annotate_AOI_image</a></code></li>
<li><code><a title="QDMPy.fit_plots.annotate_ROI_image" href="#QDMPy.fit_plots.annotate_ROI_image">annotate_ROI_image</a></code></li>
<li><code><a title="QDMPy.fit_plots.deviation_from_mean" href="#QDMPy.fit_plots.deviation_from_mean">deviation_from_mean</a></code></li>
<li><code><a title="QDMPy.fit_plots.get_colormap_range" href="#QDMPy.fit_plots.get_colormap_range">get_colormap_range</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max" href="#QDMPy.fit_plots.min_max">min_max</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max_sym_mean" href="#QDMPy.fit_plots.min_max_sym_mean">min_max_sym_mean</a></code></li>
<li><code><a title="QDMPy.fit_plots.min_max_sym_zero" href="#QDMPy.fit_plots.min_max_sym_zero">min_max_sym_zero</a></code></li>
<li><code><a title="QDMPy.fit_plots.percentile" href="#QDMPy.fit_plots.percentile">percentile</a></code></li>
<li><code><a title="QDMPy.fit_plots.percentile_sym_zero" href="#QDMPy.fit_plots.percentile_sym_zero">percentile_sym_zero</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_PL_images" href="#QDMPy.fit_plots.plot_AOI_PL_images">plot_AOI_PL_images</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_spectra" href="#QDMPy.fit_plots.plot_AOI_spectra">plot_AOI_spectra</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_AOI_spectra_fit" href="#QDMPy.fit_plots.plot_AOI_spectra_fit">plot_AOI_spectra_fit</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_ROI_PL_image" href="#QDMPy.fit_plots.plot_ROI_PL_image">plot_ROI_PL_image</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_ROI_avg_fit" href="#QDMPy.fit_plots.plot_ROI_avg_fit">plot_ROI_avg_fit</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_image" href="#QDMPy.fit_plots.plot_image">plot_image</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_image_on_ax" href="#QDMPy.fit_plots.plot_image_on_ax">plot_image_on_ax</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_param_image" href="#QDMPy.fit_plots.plot_param_image">plot_param_image</a></code></li>
<li><code><a title="QDMPy.fit_plots.plot_param_images" href="#QDMPy.fit_plots.plot_param_images">plot_param_images</a></code></li>
<li><code><a title="QDMPy.fit_plots.set_mpl_rcparams" href="#QDMPy.fit_plots.set_mpl_rcparams">set_mpl_rcparams</a></code></li>
<li><code><a title="QDMPy.fit_plots.strict_range" href="#QDMPy.fit_plots.strict_range">strict_range</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>