<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>QDMPy.plot.fits API documentation</title>
<meta name="description" content="This module holds functions for plotting initial processing images and fit results â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QDMPy.plot.fits</code></h1>
</header>
<section id="section-intro">
<p>This module holds functions for plotting initial processing images and fit results.</p>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="QDMPy.plot.fits.plot_ROI_PL_image" href="#QDMPy.plot.fits.plot_ROI_PL_image">plot_ROI_PL_image()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_PL_images" href="#QDMPy.plot.fits.plot_AOI_PL_images">plot_AOI_PL_images()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_ROI_avg_fits" href="#QDMPy.plot.fits.plot_ROI_avg_fits">plot_ROI_avg_fits()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_spectra" href="#QDMPy.plot.fits.plot_AOI_spectra">plot_AOI_spectra()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_spectra_fit" href="#QDMPy.plot.fits.plot_AOI_spectra_fit">plot_AOI_spectra_fit()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_param_image" href="#QDMPy.plot.fits.plot_param_image">plot_param_image()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_param_images" href="#QDMPy.plot.fits.plot_param_images">plot_param_images()</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_params_flattened" href="#QDMPy.plot.fits.plot_params_flattened">plot_params_flattened()</a></code></li>
<li><code><a title="QDMPy.plot.fits._add_patch_rect" href="#QDMPy.plot.fits._add_patch_rect">_add_patch_rect()</a></code></li>
<li><code><a title="QDMPy.plot.fits._annotate_ROI_image" href="#QDMPy.plot.fits._annotate_ROI_image">_annotate_ROI_image()</a></code></li>
<li><code><a title="QDMPy.plot.fits._annotate_AOI_image" href="#QDMPy.plot.fits._annotate_AOI_image">_annotate_AOI_image()</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># - coding: utf-8 -*-
&#34;&#34;&#34;
This module holds functions for plotting initial processing images and fit results.

Functions
---------
 - `QDMPy.plot.fits.plot_ROI_PL_image`
 - `QDMPy.plot.fits.plot_AOI_PL_images`
 - `QDMPy.plot.fits.plot_ROI_avg_fits`
 - `QDMPy.plot.fits.plot_AOI_spectra`
 - `QDMPy.plot.fits.plot_AOI_spectra_fit`
 - `QDMPy.plot.fits.plot_param_image`
 - `QDMPy.plot.fits.plot_param_images`
 - `QDMPy.plot.fits.plot_params_flattened`
 - `QDMPy.plot.fits._add_patch_rect`
 - `QDMPy.plot.fits._annotate_ROI_image`
 - `QDMPy.plot.fits._annotate_AOI_image`
&#34;&#34;&#34;

# ============================================================================

__author__ = &#34;Sam Scholten&#34;
__pdoc__ = {
    &#34;QDMPy.plot.fits.plot_ROI_PL_image&#34;: True,
    &#34;QDMPy.plot.fits.plot_AOI_PL_images&#34;: True,
    &#34;QDMPy.plot.fits.plot_ROI_avg_fits&#34;: True,
    &#34;QDMPy.plot.fits.plot_AOI_spectra&#34;: True,
    &#34;QDMPy.plot.fits.plot_AOI_spectra_fit&#34;: True,
    &#34;QDMPy.plot.fits.plot_param_image&#34;: True,
    &#34;QDMPy.plot.fits.plot_param_images&#34;: True,
    &#34;QDMPy.plot.fits.plot_params_flattened&#34;: True,
    &#34;QDMPy.plot.fits._add_patch_rect&#34;: True,
    &#34;QDMPy.plot.fits._annotate_ROI_image&#34;: True,
    &#34;QDMPy.plot.fits._annotate_AOI_image&#34;: True,
}

# ============================================================================

import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import numpy as np
import matplotlib.patches as patches
import math
import warnings

# ============================================================================

import QDMPy.fit._models as fit_models
import QDMPy.systems
import QDMPy.io.json2dict
import QDMPy.io.raw
import QDMPy.plot.common as plot_common
import QDMPy.constants

# ===========================================================================


def plot_ROI_PL_image(options, PL_image):
    &#34;&#34;&#34;
    Plots full PL image with ROI region annotated.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image : np array, 2D
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
        not cut down to ROI.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = plot_common._get_colormap_range(
        options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image
    )

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_common.plot_image_on_ax(
        fig,
        ax,
        options,
        PL_image,
        &#34;PL - ROI&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
    )

    if options[&#34;annotate_image_regions&#34;]:
        _annotate_ROI_image(options, ax)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;PL - ROI.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_AOI_PL_images(options, PL_image_ROI):
    &#34;&#34;&#34;
    Plots PL image cut down to ROI, with annotated AOI regions.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image_ROI : np array, 2D
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
        cut down to ROI.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    fig, ax = plt.subplots(constrained_layout=True)
    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = plot_common._get_colormap_range(
        options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image_ROI
    )

    fig, ax = plot_common.plot_image_on_ax(
        fig,
        ax,
        options,
        PL_image_ROI,
        &#34;PL - AOIs&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
    )

    if options[&#34;annotate_image_regions&#34;]:
        _annotate_AOI_image(options, ax)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;PL - AOIs.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_ROI_avg_fits(options, backend_ROI_results_lst):
    &#34;&#34;&#34;
    Plots fit of spectrum averaged across ROI, as well as corresponding residual values.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    backend_ROI_results_lst : list of tuples
        Format: (fit_backend, `QDMPy.fit._shared.ROIAvgFitResult` objects), for each fit_backend

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 2
    figsize[1] *= 1.5

    fig = plt.figure(
        figsize=figsize, constrained_layout=False
    )  # constrained doesn&#39;t work well here?
    # xstart, ystart, xend, yend [units are fraction of the image frame, from bottom left corner]
    spectrum_frame = fig.add_axes((0.1, 0.3, 0.8, 0.6))

    lspec_names = []
    lspec_lines = []

    spectrum_frame.plot(
        backend_ROI_results_lst[0].sweep_list,
        backend_ROI_results_lst[0].pl_roi,
        label=f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;,
        ls=&#34; &#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;firebrick&#34;,
    )
    lspec_names.append(f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;)
    lspec_lines.append(
        Line2D(
            [0],
            [0],
            ls=&#34; &#34;,
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=&#34;firebrick&#34;,
        )
    )

    high_res_sweep_list = np.linspace(
        np.min(backend_ROI_results_lst[0].sweep_list),
        np.max(backend_ROI_results_lst[0].sweep_list),
        10000,
    )
    high_res_init_fit = backend_ROI_results_lst[0].fit_model(
        backend_ROI_results_lst[0].init_param_guess, high_res_sweep_list
    )
    spectrum_frame.plot(
        high_res_sweep_list,
        high_res_init_fit,
        linestyle=(0, (1, 1)),
        label=&#34;init guess&#34;,
        c=&#34;darkgreen&#34;,
    )
    lspec_names.append(&#34;init guess&#34;)
    lspec_lines.append(
        Line2D(
            [0],
            [0],
            linestyle=(0, (1, 1)),
            c=&#34;darkgreen&#34;,
        )
    )

    spectrum_frame.set_xticklabels([])  # remove from first frame

    spectrum_frame.grid()
    spectrum_frame.set_ylabel(&#34;PL (a.u.)&#34;)

    # residual plot
    residual_frame = fig.add_axes((0.1, 0.1, 0.8, 0.2))

    lresid_names = []
    lresid_lines = []

    residual_frame.grid()

    residual_frame.set_xlabel(&#34;Sweep parameter&#34;)
    residual_frame.set_ylabel(&#34;Fit - data (a.u.)&#34;)

    for res in backend_ROI_results_lst:

        # ODMR spectrum_frame
        high_res_best_fit = res.fit_model(res.best_params, high_res_sweep_list)

        spectrum_frame.plot(
            high_res_sweep_list,
            high_res_best_fit,
            linestyle=&#34;--&#34;,
            label=f&#34;{res.fit_backend} best fit&#34;,
            c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;roifit_linecolor&#34;],
        )
        lspec_names.append(f&#34;{res.fit_backend} best fit&#34;)
        lspec_lines.append(
            Line2D(
                [0],
                [0],
                linestyle=&#34;--&#34;,
                c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;roifit_linecolor&#34;],
            )
        )

        residual_xdata = res.sweep_list
        residual_ydata = res.fit_model(res.best_params, res.sweep_list) - res.pl_roi

        residual_frame.plot(
            residual_xdata,
            residual_ydata,
            label=f&#34;{res.fit_backend} residual&#34;,
            ls=&#34;dashed&#34;,
            c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
        )
        lresid_names.append(f&#34;{res.fit_backend} residual&#34;)
        lresid_lines.append(
            Line2D(
                [0],
                [0],
                ls=&#34;dashed&#34;,
                c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
                marker=&#34;o&#34;,
                mfc=&#34;w&#34;,
                mec=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
            )
        )

        res.savejson(f&#34;ROI_avg_fit_{res.fit_backend}.json&#34;, options[&#34;data_dir&#34;])

    # https://jdhao.github.io/2018/01/23/matplotlib-legend-outside-of-axes/
    # https://matplotlib.org/3.2.1/gallery/lines_bars_and_markers/linestyles.html
    legend_names = lspec_names.copy()
    legend_names.extend(lresid_names)

    legend_lines = lspec_lines.copy()
    legend_lines.extend(lresid_lines)

    spectrum_frame.legend(
        legend_lines,
        legend_names,
        loc=&#34;lower left&#34;,
        bbox_to_anchor=(0.0, 1.01),
        fontsize=&#34;medium&#34;,
        ncol=len(legend_names),
        borderaxespad=0,
        frameon=False,
    )
    fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    # spectrum_frame.legend()

    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;] / (f&#34;ROI_avg_fit_{res.fit_backend}.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig


# ============================================================================


def plot_AOI_spectra(options, sig, ref, sweep_list):
    &#34;&#34;&#34;
    Plots spectra from each AOI, as well as subtraction and division norms.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    AOIs = QDMPy.io.raw._define_AOIs(options)

    # pre-process data to plot
    sig_avgs = []
    ref_avgs = []
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nanmean(np.nanmean(sig[:, AOI[0], AOI[1]], axis=2), axis=1)
        ref_avg = np.nanmean(np.nanmean(ref[:, AOI[0], AOI[1]], axis=2), axis=1)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    num_wide = 2 if len(AOIs) &lt; 2 else len(AOIs)
    figsize[0] *= num_wide
    figsize[1] *= 2
    fig, axs = plt.subplots(
        2, num_wide, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    for i, AOI in enumerate(AOIs):

        # plot sig
        axs[0, i].plot(
            sweep_list,
            sig_avgs[i],
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[0, i].plot(
            sweep_list,
            ref_avgs[i],
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[0, i].legend()
        axs[0, i].grid(True)
        axs[0, i].set_title(
            &#34;AOI &#34; + str(i + 1),
            fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i + 1]},
        )
        axs[0, i].set_ylabel(&#34;PL (a.u.)&#34;)

    linestyles = [
        &#34;--&#34;,
        &#34;-.&#34;,
        (0, (1, 1)),
        (0, (5, 10)),
        (0, (5, 5)),
        (0, (5, 1)),
        (0, (3, 10, 1, 10)),
        (0, (3, 5, 1, 5)),
        (0, (3, 1, 1, 1)),
        (0, (3, 5, 1, 5, 1, 5)),
        (0, (3, 10, 1, 10, 1, 10)),
        (0, (3, 1, 1, 1, 1, 1)),
    ]

    for i in range(len(AOIs)):
        # plot subtraction norm
        axs[1, 0].plot(
            sweep_list,
            1 + (sig_avgs[i] - ref_avgs[i]) / (sig_avgs[i] + ref_avgs[i]),
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )
        axs[1, 0].legend()
        axs[1, 0].grid(True)
        axs[1, 0].set_title(
            &#34;Subtraction Normalisation (Michelson contrast, 1 + (sig - ref / sig + ref) )&#34;
        )
        axs[1, 0].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 0].set_ylabel(&#34;PL (a.u.)&#34;)

        # plot division norm
        axs[1, 1].plot(
            sweep_list,
            sig_avgs[i] / ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )

        axs[1, 1].legend()
        axs[1, 1].grid(True)
        axs[1, 1].set_title(&#34;Division Normalisation (Weber contrast, sig / ref)&#34;)
        axs[1, 1].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 1].set_ylabel(&#34;PL (a.u.)&#34;)

    # delete axes that we didn&#39;t use
    for i in range(len(AOIs)):
        if i &lt; len(
            options[&#34;system&#34;].option_choices(&#34;normalisation&#34;)
        ):  # we used these (normalisation)
            continue
        else:  # we didn&#39;t use these
            fig.delaxes(axs[1, i])

    if len(AOIs) == 1:
        # again, didn&#39;t use
        fig.delaxes(axs[0, 1])

    output_dict = {}
    for i in range(len(AOIs)):
        output_dict[&#34;AOI_sig_avg&#34; + &#34;_&#34; + str(i + 1)] = sig_avgs[i]
        output_dict[&#34;AOI_ref_avg&#34; + &#34;_&#34; + str(i + 1)] = ref_avgs[i]

    QDMPy.io.json2dict.dict_to_json(output_dict, &#34;AOI_spectra.json&#34;, options[&#34;data_dir&#34;])

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra.&#34; + options[&#34;save_fig_type&#34;]))
    return fig


# ============================================================================


def plot_AOI_spectra_fit(
    options,
    sig,
    ref,
    sweep_list,
    fit_result_collection_lst,
    fit_model,
):
    &#34;&#34;&#34;
    Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
    pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
    average fit is plot against the fit of all of the others for comparison.

    Note here and elsewhere the single pixel check is the first element of the AOI array.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    fit_result_collection_lst : list
        List of `QDMPy.fit._shared.FitResultCollection` objects (one for each fit_backend)
        holding ROI, AOI fit results

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # rows:
    # ROI avg, single pixel, then each AOI
    # columns:
    # sig &amp; ref, sub &amp; div norm, fit -&gt; compared to ROI {raw, fit, ROI_avg_fit}

    AOIs = QDMPy.io.raw._define_AOIs(options)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 3  # number of columns
    figsize[1] *= 2 + len(AOIs)  # number of rows

    fig, axs = plt.subplots(
        2 + len(AOIs), 3, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    # pre-process raw data to plot
    sig_avgs = []
    ref_avgs = []
    # add roi data
    roi_avg_sig = np.nanmean(np.nanmean(sig, axis=2), axis=1)
    roi_avg_ref = np.nanmean(np.nanmean(ref, axis=2), axis=1)
    sig_avgs.append(roi_avg_sig)
    ref_avgs.append(roi_avg_ref)
    # add single pixel check
    pixel_sig = sig[:, options[&#34;single_pixel_check&#34;][1], options[&#34;single_pixel_check&#34;][0]]
    pixel_ref = ref[:, options[&#34;single_pixel_check&#34;][1], options[&#34;single_pixel_check&#34;][0]]
    sig_avgs.append(pixel_sig)
    ref_avgs.append(pixel_ref)
    # add AOI data
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nanmean(np.nanmean(sig[:, AOI[0], AOI[1]], axis=2), axis=1)
        ref_avg = np.nanmean(np.nanmean(ref[:, AOI[0], AOI[1]], axis=2), axis=1)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    # plot sig, ref data as first column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):

        # plot sig
        axs[i, 0].plot(
            sweep_list,
            sig,
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[i, 0].plot(
            sweep_list,
            ref,
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[i, 0].legend()
        axs[i, 0].grid(True)
        if not i:
            axs[i, 0].set_title(&#34;ROI avg&#34;)
        elif i == 1:
            axs[i, 0].set_title(&#34;Single Pixel Check&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]})
        else:
            axs[i, 0].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]}
            )
        axs[i, 0].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 0].set_xlabel(&#34;Sweep parameter&#34;)

    # plot normalisation as second column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):
        axs[i, 1].plot(
            sweep_list,
            1 + (sig - ref) / (sig + ref),
            label=&#34;subtraction&#34;,
            c=&#34;firebrick&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;lightcoral&#34;,
            mec=&#34;maroon&#34;,
        )
        axs[i, 1].plot(
            sweep_list,
            sig / ref,
            label=&#34;division&#34;,
            c=&#34;cadetblue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;powderblue&#34;,
            mec=&#34;darkslategrey&#34;,
        )

        axs[i, 1].legend()
        axs[i, 1].grid(True)
        if not i:
            axs[i, 1].set_title(&#34;ROI avg - Normalisation&#34;)
        elif i == 1:
            axs[i, 1].set_title(
                &#34;Single Pixel Check - Normalisation&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 1].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Normalisation&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )
        axs[i, 1].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 1].set_xlabel(
        &#34;Sweep parameter&#34;
    )  # this is meant to be less indented than the line above

    high_res_xdata = np.linspace(
        np.min(fit_result_collection_lst[0].roi_avg_fit_result.sweep_list),
        np.max(fit_result_collection_lst[0].roi_avg_fit_result.sweep_list),
        10000,
    )

    # loop of fit backends first
    for fit_backend_number, fit_backend_fit_result in enumerate(fit_result_collection_lst):
        fit_backend_name = fit_backend_fit_result.fit_backend

        fit_params_lst = [
            fit_backend_fit_result.roi_avg_fit_result.best_params,
            fit_backend_fit_result.single_pixel_fit_result,
            *fit_backend_fit_result.AOI_fit_results_lst,
        ]
        # now plot fits as third column
        for i, (fit_param_ar, sig, ref) in enumerate(zip(fit_params_lst, sig_avgs, ref_avgs)):
            if not options[&#34;used_ref&#34;]:
                sig_norm = sig
            elif options[&#34;normalisation&#34;] == &#34;div&#34;:
                sig_norm = sig / ref
            elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
                sig_norm = 1 + (sig - ref) / (sig + ref)

            best_fit_ydata = fit_model(fit_param_ar, high_res_xdata)
            roi_fit_ydata = fit_model(
                fit_backend_fit_result.roi_avg_fit_result.best_params, high_res_xdata
            )

            # this is the first loop -&gt; plot raw data, add titles
            if not fit_backend_number:

                # raw data
                axs[i, 2].plot(
                    sweep_list,
                    sig_norm,
                    label=f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;,
                    ls=&#34;&#34;,
                    marker=&#34;o&#34;,
                    ms=3.5,
                    mfc=&#34;goldenrod&#34;,
                    mec=&#34;k&#34;,
                )
                if not i:
                    axs[i, 2].set_title(&#34;ROI avg - Fit&#34;)
                elif i == 1:
                    axs[i, 2].set_title(
                        &#34;Single Pixel Check - Fit&#34;,
                        fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]},
                    )
                else:
                    axs[i, 2].set_title(
                        &#34;AOI &#34; + str(i - 1) + &#34; avg - Fit&#34;,
                        fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
                    )
            # roi avg fit (as comparison)
            if i:
                axs[i, 2].plot(
                    high_res_xdata,
                    roi_fit_ydata,
                    label=f&#34;ROI avg fit - {fit_backend_name}&#34;,
                    ls=&#34;dashed&#34;,
                    c=options[&#34;fit_backend_colors&#34;][fit_backend_name][&#34;aoi_roi_fit_linecolor&#34;],
                )
            # best fit
            axs[i, 2].plot(
                high_res_xdata,
                best_fit_ydata,
                label=f&#34;fit - {fit_backend_name}&#34;,
                ls=&#34;dashed&#34;,
                c=options[&#34;fit_backend_colors&#34;][fit_backend_name][&#34;aoi_best_fit_linecolor&#34;],
            )

            axs[i, 2].legend()
            axs[i, 2].grid(True)
            axs[i, 2].set_ylabel(&#34;PL (a.u.)&#34;)

    axs[-1, 2].set_xlabel(&#34;Sweep parameter&#34;)  # this is meant to be less indented than line above

    # currently not saving any of the data from this plot (not sure what the user would ever want)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra_fits.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_param_image(options, fit_model, pixel_fit_params, param_name, param_number=0):
    &#34;&#34;&#34;
    Plots an image corresponding to a single parameter in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.


    Optional arguments
    ------------------
    param_number : int
        Which version of the parameter you want. I.e. there might be 8 independent parameters
        in the fit model called &#39;pos&#39;, each labeled &#39;pos_0&#39;, &#39;pos_1&#39; etc. Default: 0.


    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    image = pixel_fit_params[param_name + &#34;_&#34; + str(param_number)]

    if param_name == &#34;residual&#34;:
        c_range = plot_common._get_colormap_range(
            options[&#34;colormap_range_dicts&#34;][&#34;residual_images&#34;], image
        )
        c_map = options[&#34;colormaps&#34;][&#34;residual_images&#34;]
    else:
        c_range = plot_common._get_colormap_range(
            options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image
        )
        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]
    c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_common.plot_image_on_ax(
        fig, ax, options, image, param_name + &#34;_&#34; + str(param_number), c_map, c_range, c_label
    )

    np.savetxt(options[&#34;data_dir&#34;] / (param_name + &#34;_&#34; + str(param_number) + &#34;.txt&#34;), image)
    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;]
            / (param_name + &#34;_&#34; + str(param_number) + &#34;.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig


# ============================================================================


def plot_param_images(options, fit_model, pixel_fit_params, param_name):
    &#34;&#34;&#34;
    Plots images for all independent versions of a single parameter type in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # if no fit completed
    if pixel_fit_params is None:
        warnings.warn(
            &#34;&#39;pixel_fit_params&#39; arg to function &#39;plot_param_images&#39; is &#39;None&#39;.\n&#34;
            + &#34;Probably no pixel fitting completed.&#34;  # noqa: W503
        )
        return None

    # plot 2 columns wide, as many rows as required

    # first get keys we need
    our_keys = []
    for key in pixel_fit_params:
        if key.startswith(param_name):
            our_keys.append(key)

    # this is an inner function so no one uses it elsewhere/protect namespace
    def param_sorter(param):
        strings = param.split(&#34;_&#34;)  # e.g. &#34;amp_exp_2&#34; -&gt; [&#34;amp&#34;, &#34;exp&#34;, &#34;2&#34;]
        # all we need here is the number at the end actually
        # param_name_split = strings[:-1]  # list of &#39;words&#39;, e.g. [&#34;amp&#34;, &#34;exp&#34;]
        num = strings[-1]  # grab the number e.g. &#34;2
        return int(num)

    # sort based on number (just in case)
    our_keys.sort(key=param_sorter)
    nk = len(our_keys)

    if nk == 1:
        # just one image, so plot normally
        fig = plot_param_image(options, fit_model, pixel_fit_params, param_name, 0)
    else:
        if nk &lt;= 8:
            num_columns = 4
            num_rows = 2
        else:
            num_columns = 2
            num_rows = math.ceil(nk / 2)

        figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
        figsize[0] *= num_columns
        figsize[1] *= num_rows

        figsize[0] *= 3 / 4
        figsize[1] *= 3 / 4

        fig, axs = plt.subplots(
            num_rows,
            num_columns,
            figsize=figsize,
            sharex=False,
            sharey=False,
            constrained_layout=True,
        )

        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]

        # plot 8-lorentzian peaks in a more helpful way
        if nk &lt;= 8 and any([f.startswith(&#34;lorentzian&#34;) for f in options[&#34;fit_functions&#34;]]):
            param_nums = []  # [0, 1, 2, 3, 7, 6, 5, 4] etc.
            param_nums.extend(list(range(nk // 2)))
            if nk % 2:
                param_nums.append(nk // 2 + 1)
            param_nums.extend(list(range(nk - 1, (nk - 1) // 2, -1)))  # range(start, stop, step)
            param_axis_iterator = zip(param_nums, axs.flatten())
        # otherwise plot in a more conventional order
        else:
            param_axis_iterator = enumerate(axs.flatten())

        for param_number, ax in param_axis_iterator:

            param_key = param_name + &#34;_&#34; + str(param_number)

            try:
                image_data = pixel_fit_params[param_key]
            except KeyError:
                # we have one too many axes (i.e. 7 params, 8 subplots), delete the axs
                fig.delaxes(ax)
                break

            c_range = plot_common._get_colormap_range(
                options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image_data
            )
            c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

            plot_common.plot_image_on_ax(
                fig,
                ax,
                options,
                image_data,
                param_key,
                c_map,
                c_range,
                c_label,
            )

        if options[&#34;save_plots&#34;]:
            fig.savefig(options[&#34;output_dir&#34;] / (param_name + &#34;.&#34; + options[&#34;save_fig_type&#34;]))

    return fig


# ============================================================================


def plot_params_flattened(options, fit_model, pixel_fit_params, roi_avg_fit_result, param_name):
    &#34;&#34;&#34;
    Compare pixel fits against flattened pixels: initial guess vs roi fit vs fit result.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    roi_avg_fit_result
        `QDMPy.fit._shared.ROIAvgFitResult` object.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.

    Returns
    -------
    fig : matplotlib Figure object

    &#34;&#34;&#34;

    # initial guess vs roi fit vs pixel fit

    param_keys = sorted([p for p in pixel_fit_params if p.startswith(param_name)])

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()

    height = len(param_keys)
    width = 1
    figsize[0] *= 2  # make some extra space...
    figsize[1] = figsize[1] * height / 2 if height &gt; 1 else figsize[1]

    fig, axs = plt.subplots(height, width, sharex=True, figsize=figsize, constrained_layout=True)
    # axs indexed: axs[row, col] (n_cols = 1 here, so index linearly)
    if type(axs) is not np.ndarray:
        axs = np.array([axs])

    if param_name == &#34;residual&#34;:
        param_guesses = [
            fit_model.residuals_scipyfit(
                roi_avg_fit_result.init_param_guess,
                roi_avg_fit_result.sweep_list,
                roi_avg_fit_result.pl_roi,
            ).sum()
        ]

        param_roi_fits = [
            fit_model.residuals_scipyfit(
                roi_avg_fit_result.best_params,
                roi_avg_fit_result.sweep_list,
                roi_avg_fit_result.pl_roi,
            ).sum()
        ]
    else:
        param_guesses = []
        param_roi_fits = []
        for fn_obj in fit_model.fn_chain:
            for param_num, param_root in enumerate(fn_obj.param_defn):
                if param_root == param_name:
                    param_guesses.append(
                        roi_avg_fit_result.init_param_guess[
                            fn_obj.this_fn_param_indices[param_num]
                        ]
                    )
                    param_roi_fits.append(
                        roi_avg_fit_result.best_params[fn_obj.this_fn_param_indices[param_num]]
                    )

    fig.suptitle(param_name, fontsize=16)

    axs[-1].set_xlabel(&#34;Pixel # (flattened)&#34;)
    for ax in axs:
        ax.set_ylabel(fit_models.get_param_unit(fit_model, param_name, 0))
        ax.grid()

    # uses the default color cycle... i.e.:
    prop_cycle = plt.rcParams[&#34;axes.prop_cycle&#34;]
    colors = prop_cycle.by_key()[&#34;color&#34;]

    legend_names = [&#34;Initial guesses&#34;, &#34;ROI fits&#34;]
    # https://matplotlib.org/3.2.1/gallery/lines_bars_and_markers/linestyles.html
    custom_lines = [
        Line2D([0], [0], color=&#34;k&#34;, ls=(0, (1, 1)), lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2),
        Line2D([0], [0], color=&#34;k&#34;, ls=(0, (5, 1)), lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2),
    ]

    for i, guess in enumerate(param_guesses):
        axs[i].axhline(
            guess,
            ls=(0, (1, 1)),
            c=&#34;k&#34;,
            zorder=10,
            lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2,
        )

    for i, roi_fit in enumerate(param_roi_fits):
        axs[i].axhline(
            roi_fit,
            ls=(0, (5, 1)),
            lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2,
            c=&#34;k&#34;,
            zorder=5,
        )

    for i, (param_key, color) in enumerate(zip(param_keys, colors)):
        axs[i].plot(
            pixel_fit_params[param_key].flatten(),
            label=param_key,
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            ms=mpl.rcParams[&#34;lines.markersize&#34;] // 2,
            mec=color,
            ls=&#34;&#34;,
        )
        legend_names.append(param_key)
        custom_lines.append(
            Line2D(
                [0],
                [0],
                marker=&#34;o&#34;,
                mfc=&#34;w&#34;,
                ms=mpl.rcParams[&#34;lines.markersize&#34;] * 2,
                mec=color,
                ls=&#34;&#34;,
            )
        )

    # https://jdhao.github.io/2018/01/23/matplotlib-legend-outside-of-axes/
    axs[0].legend(
        custom_lines,
        legend_names,
        loc=&#34;lower left&#34;,
        bbox_to_anchor=(0.0, 1.01),
        ncol=height + 2,
        borderaxespad=0,
        frameon=False,
        fontsize=&#34;medium&#34;,
    )

    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;] / (f&#34;{param_name}_fit_flattened.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig


# ============================================================================


def _add_patch_rect(ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Adds a rectangular annotation onto ax.

    Arguments
    ---------
    ax : matplotlib Axis object

    rect_corner_x : int
        Location of top left corner of area you want to annotate, x component.

    rect_corner_y : int
        Location of top left corner of area you want to annotate, y component.

    size_x : int
        Size of area along x (horizontal axis) you want to annotate.
    size_y : int
        Size of area along y (vertical) axis you want to annotate.

    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    &#34;&#34;&#34;
    rect = patches.Rectangle(
        (rect_corner_x, rect_corner_y),
        int(size_x),
        int(size_y),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        ax.text(
            rect_corner_x + 0.95 * size_x,  # label posn.: top right
            rect_corner_y,
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;bottom&#34;},
        )


# ============================================================================


def _annotate_ROI_image(options, ax):
    &#34;&#34;&#34;
    Annotates ROI onto a given Axis object. Generally used on a PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1
    if options[&#34;ROI&#34;] == &#34;Full&#34;:
        return None
    elif options[&#34;ROI&#34;] == &#34;Rectangle&#34;:

        # these options are [x, y], opposite to data indexing convention
        start_x, start_y = options[&#34;ROI_start&#34;]
        end_x, end_y = options[&#34;ROI_end&#34;]

        _add_patch_rect(
            ax,
            start_x,
            start_y,
            end_x - start_x + 1,
            end_y - start_y + 1,
            label=&#34;ROI&#34;,
            edgecolor=&#34;r&#34;,
        )
    else:
        raise QDMPy.systems.OptionsError(
            &#34;ROI&#34;, options[&#34;ROI&#34;], options[&#34;system&#34;], custom_msg=&#34;Unknown ROI encountered.&#34;
        )


# ============================================================================


def _annotate_AOI_image(options, ax):
    &#34;&#34;&#34;
    Annotates AOI onto a given Axis object. Generally used on PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1

    # annotate single pixel check
    corner_x = options[&#34;single_pixel_check&#34;][0]
    corner_y = options[&#34;single_pixel_check&#34;][1]
    size = 1
    _add_patch_rect(
        ax, corner_x, corner_y, size, size, label=&#34;PX check&#34;, edgecolor=options[&#34;AOI_colors&#34;][0]
    )

    i = 0
    while True:
        i += 1
        try:
            # these options are [x, y], opposite to data indexing convention
            start = options[&#34;AOI_&#34; + str(i) + &#34;_start&#34;]
            end = options[&#34;AOI_&#34; + str(i) + &#34;_end&#34;]
            if start is None or end is None:
                continue

            # need to handle binning???
            _add_patch_rect(
                ax,
                *start,
                end[0] - start[0] + 1,
                end[1] - start[1] + 1,
                label=&#34;AOI &#34; + str(i),
                edgecolor=options[&#34;AOI_colors&#34;][i],
            )
        except KeyError:
            break


# ============================================================================</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="QDMPy.plot.fits._add_patch_rect"><code class="name flex">
<span>def <span class="ident">_add_patch_rect</span></span>(<span>ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor='b')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a rectangular annotation onto ax.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axis object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>rect_corner_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Location of top left corner of area you want to annotate, x component.</dd>
<dt><strong><code>rect_corner_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Location of top left corner of area you want to annotate, y component.</dd>
<dt><strong><code>size_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of area along x (horizontal axis) you want to annotate.</dd>
<dt><strong><code>size_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of area along y (vertical) axis you want to annotate.</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>label : str
Text to label annotated square with. Color is defined by edgecolor. Default: None.</p>
<p>edgecolor : str
Color of label and edge of annotation. Default: "b".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _add_patch_rect(ax, rect_corner_x, rect_corner_y, size_x, size_y, label=None, edgecolor=&#34;b&#34;):
    &#34;&#34;&#34;
    Adds a rectangular annotation onto ax.

    Arguments
    ---------
    ax : matplotlib Axis object

    rect_corner_x : int
        Location of top left corner of area you want to annotate, x component.

    rect_corner_y : int
        Location of top left corner of area you want to annotate, y component.

    size_x : int
        Size of area along x (horizontal axis) you want to annotate.
    size_y : int
        Size of area along y (vertical) axis you want to annotate.

    Optional arguments
    ------------------
    label : str
        Text to label annotated square with. Color is defined by edgecolor. Default: None.

    edgecolor : str
        Color of label and edge of annotation. Default: &#34;b&#34;.

    &#34;&#34;&#34;
    rect = patches.Rectangle(
        (rect_corner_x, rect_corner_y),
        int(size_x),
        int(size_y),
        linewidth=1,
        edgecolor=edgecolor,
        facecolor=&#34;none&#34;,
    )
    ax.add_patch(rect)
    if label:
        ax.text(
            rect_corner_x + 0.95 * size_x,  # label posn.: top right
            rect_corner_y,
            label,
            {&#34;color&#34;: edgecolor, &#34;fontsize&#34;: 10, &#34;ha&#34;: &#34;center&#34;, &#34;va&#34;: &#34;bottom&#34;},
        )</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits._annotate_AOI_image"><code class="name flex">
<span>def <span class="ident">_annotate_AOI_image</span></span>(<span>options, ax)</span>
</code></dt>
<dd>
<div class="desc"><p>Annotates AOI onto a given Axis object. Generally used on PL image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _annotate_AOI_image(options, ax):
    &#34;&#34;&#34;
    Annotates AOI onto a given Axis object. Generally used on PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1

    # annotate single pixel check
    corner_x = options[&#34;single_pixel_check&#34;][0]
    corner_y = options[&#34;single_pixel_check&#34;][1]
    size = 1
    _add_patch_rect(
        ax, corner_x, corner_y, size, size, label=&#34;PX check&#34;, edgecolor=options[&#34;AOI_colors&#34;][0]
    )

    i = 0
    while True:
        i += 1
        try:
            # these options are [x, y], opposite to data indexing convention
            start = options[&#34;AOI_&#34; + str(i) + &#34;_start&#34;]
            end = options[&#34;AOI_&#34; + str(i) + &#34;_end&#34;]
            if start is None or end is None:
                continue

            # need to handle binning???
            _add_patch_rect(
                ax,
                *start,
                end[0] - start[0] + 1,
                end[1] - start[1] + 1,
                label=&#34;AOI &#34; + str(i),
                edgecolor=options[&#34;AOI_colors&#34;][i],
            )
        except KeyError:
            break</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits._annotate_ROI_image"><code class="name flex">
<span>def <span class="ident">_annotate_ROI_image</span></span>(<span>options, ax)</span>
</code></dt>
<dd>
<div class="desc"><p>Annotates ROI onto a given Axis object. Generally used on a PL image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _annotate_ROI_image(options, ax):
    &#34;&#34;&#34;
    Annotates ROI onto a given Axis object. Generally used on a PL image.
    &#34;&#34;&#34;
    binning = options[&#34;additional_bins&#34;]
    if binning == 0:
        binning = 1
    if options[&#34;ROI&#34;] == &#34;Full&#34;:
        return None
    elif options[&#34;ROI&#34;] == &#34;Rectangle&#34;:

        # these options are [x, y], opposite to data indexing convention
        start_x, start_y = options[&#34;ROI_start&#34;]
        end_x, end_y = options[&#34;ROI_end&#34;]

        _add_patch_rect(
            ax,
            start_x,
            start_y,
            end_x - start_x + 1,
            end_y - start_y + 1,
            label=&#34;ROI&#34;,
            edgecolor=&#34;r&#34;,
        )
    else:
        raise QDMPy.systems.OptionsError(
            &#34;ROI&#34;, options[&#34;ROI&#34;], options[&#34;system&#34;], custom_msg=&#34;Unknown ROI encountered.&#34;
        )</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_AOI_PL_images"><code class="name flex">
<span>def <span class="ident">plot_AOI_PL_images</span></span>(<span>options, PL_image_ROI)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots PL image cut down to ROI, with annotated AOI regions.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>PL_image_ROI</code></strong> :&ensp;<code>np array, 2D</code></dt>
<dd>Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
cut down to ROI.</dd>
<dt><strong><code>AOIs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
that can be used to directly index into image to provide a view into just the AOI
part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
general we have more than one area of interest.
I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_PL_images(options, PL_image_ROI):
    &#34;&#34;&#34;
    Plots PL image cut down to ROI, with annotated AOI regions.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image_ROI : np array, 2D
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned and
        cut down to ROI.

    AOIs : list
        List of AOI regions. Much like ROI object, these are a length-2 list of np meshgrids
        that can be used to directly index into image to provide a view into just the AOI
        part of the image. E.g. sig_AOI = sig[:, AOI[0], AOI[1]]. Returns a list as in
        general we have more than one area of interest.
        I.e. sig_AOI_1 = sig[:, AOIs[1][0], AOIs[1][1]]

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    fig, ax = plt.subplots(constrained_layout=True)
    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = plot_common._get_colormap_range(
        options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image_ROI
    )

    fig, ax = plot_common.plot_image_on_ax(
        fig,
        ax,
        options,
        PL_image_ROI,
        &#34;PL - AOIs&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
    )

    if options[&#34;annotate_image_regions&#34;]:
        _annotate_AOI_image(options, ax)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;PL - AOIs.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_AOI_spectra"><code class="name flex">
<span>def <span class="ident">plot_AOI_spectra</span></span>(<span>options, sig, ref, sweep_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots spectra from each AOI, as well as subtraction and division norms.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, y, x]</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, y, x]</dd>
<dt><strong><code>sweep_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of sweep parameter values (with removed unwanted sweeps at start/end)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_spectra(options, sig, ref, sweep_list):
    &#34;&#34;&#34;
    Plots spectra from each AOI, as well as subtraction and division norms.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    AOIs = QDMPy.io.raw._define_AOIs(options)

    # pre-process data to plot
    sig_avgs = []
    ref_avgs = []
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nanmean(np.nanmean(sig[:, AOI[0], AOI[1]], axis=2), axis=1)
        ref_avg = np.nanmean(np.nanmean(ref[:, AOI[0], AOI[1]], axis=2), axis=1)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    num_wide = 2 if len(AOIs) &lt; 2 else len(AOIs)
    figsize[0] *= num_wide
    figsize[1] *= 2
    fig, axs = plt.subplots(
        2, num_wide, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    for i, AOI in enumerate(AOIs):

        # plot sig
        axs[0, i].plot(
            sweep_list,
            sig_avgs[i],
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[0, i].plot(
            sweep_list,
            ref_avgs[i],
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[0, i].legend()
        axs[0, i].grid(True)
        axs[0, i].set_title(
            &#34;AOI &#34; + str(i + 1),
            fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i + 1]},
        )
        axs[0, i].set_ylabel(&#34;PL (a.u.)&#34;)

    linestyles = [
        &#34;--&#34;,
        &#34;-.&#34;,
        (0, (1, 1)),
        (0, (5, 10)),
        (0, (5, 5)),
        (0, (5, 1)),
        (0, (3, 10, 1, 10)),
        (0, (3, 5, 1, 5)),
        (0, (3, 1, 1, 1)),
        (0, (3, 5, 1, 5, 1, 5)),
        (0, (3, 10, 1, 10, 1, 10)),
        (0, (3, 1, 1, 1, 1, 1)),
    ]

    for i in range(len(AOIs)):
        # plot subtraction norm
        axs[1, 0].plot(
            sweep_list,
            1 + (sig_avgs[i] - ref_avgs[i]) / (sig_avgs[i] + ref_avgs[i]),
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )
        axs[1, 0].legend()
        axs[1, 0].grid(True)
        axs[1, 0].set_title(
            &#34;Subtraction Normalisation (Michelson contrast, 1 + (sig - ref / sig + ref) )&#34;
        )
        axs[1, 0].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 0].set_ylabel(&#34;PL (a.u.)&#34;)

        # plot division norm
        axs[1, 1].plot(
            sweep_list,
            sig_avgs[i] / ref_avgs[i],
            label=&#34;AOI &#34; + str(i + 1),
            c=options[&#34;AOI_colors&#34;][i + 1],
            ls=linestyles[i],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;AOI_colors&#34;][i + 1],
        )

        axs[1, 1].legend()
        axs[1, 1].grid(True)
        axs[1, 1].set_title(&#34;Division Normalisation (Weber contrast, sig / ref)&#34;)
        axs[1, 1].set_xlabel(&#34;Sweep parameter&#34;)
        axs[1, 1].set_ylabel(&#34;PL (a.u.)&#34;)

    # delete axes that we didn&#39;t use
    for i in range(len(AOIs)):
        if i &lt; len(
            options[&#34;system&#34;].option_choices(&#34;normalisation&#34;)
        ):  # we used these (normalisation)
            continue
        else:  # we didn&#39;t use these
            fig.delaxes(axs[1, i])

    if len(AOIs) == 1:
        # again, didn&#39;t use
        fig.delaxes(axs[0, 1])

    output_dict = {}
    for i in range(len(AOIs)):
        output_dict[&#34;AOI_sig_avg&#34; + &#34;_&#34; + str(i + 1)] = sig_avgs[i]
        output_dict[&#34;AOI_ref_avg&#34; + &#34;_&#34; + str(i + 1)] = ref_avgs[i]

    QDMPy.io.json2dict.dict_to_json(output_dict, &#34;AOI_spectra.json&#34;, options[&#34;data_dir&#34;])

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra.&#34; + options[&#34;save_fig_type&#34;]))
    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_AOI_spectra_fit"><code class="name flex">
<span>def <span class="ident">plot_AOI_spectra_fit</span></span>(<span>options, sig, ref, sweep_list, fit_result_collection_lst, fit_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
average fit is plot against the fit of all of the others for comparison.</p>
<p>Note here and elsewhere the single pixel check is the first element of the AOI array.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, y, x]</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>np array, 3D</code></dt>
<dd>Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
Cut down to ROI.
Format: [sweep_vals, y, x]</dd>
<dt><strong><code>sweep_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of sweep parameter values (with removed unwanted sweeps at start/end)</dd>
<dt><strong><code>fit_result_collection_lst</code></strong> :&ensp;<code>list</code></dt>
<dd>List of <code><a title="QDMPy.fit._shared.FitResultCollection" href="../fit/_shared.html#QDMPy.fit._shared.FitResultCollection">FitResultCollection</a></code> objects (one for each fit_backend)
holding ROI, AOI fit results</dd>
<dt><strong><code>fit_model</code></strong> :&ensp;<code><a title="QDMPy.fit._models.FitModel" href="../fit/_models.html#QDMPy.fit._models.FitModel">FitModel</a></code></dt>
<dd>Model we're fitting to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_AOI_spectra_fit(
    options,
    sig,
    ref,
    sweep_list,
    fit_result_collection_lst,
    fit_model,
):
    &#34;&#34;&#34;
    Plots sig and ref spectra, sub and div normalisation and fit for the ROI average, a single
    pixel, and each of the AOIs. All stacked on top of each other for comparison. The ROI
    average fit is plot against the fit of all of the others for comparison.

    Note here and elsewhere the single pixel check is the first element of the AOI array.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    sig : np array, 3D
        Signal component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]

    ref : np array, 3D
        Reference component of raw data, reshaped and rebinned. Unwanted sweeps removed.
        Cut down to ROI.
        Format: [sweep_vals, y, x]
    sweep_list : list
        List of sweep parameter values (with removed unwanted sweeps at start/end)

    fit_result_collection_lst : list
        List of `QDMPy.fit._shared.FitResultCollection` objects (one for each fit_backend)
        holding ROI, AOI fit results

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # rows:
    # ROI avg, single pixel, then each AOI
    # columns:
    # sig &amp; ref, sub &amp; div norm, fit -&gt; compared to ROI {raw, fit, ROI_avg_fit}

    AOIs = QDMPy.io.raw._define_AOIs(options)

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 3  # number of columns
    figsize[1] *= 2 + len(AOIs)  # number of rows

    fig, axs = plt.subplots(
        2 + len(AOIs), 3, figsize=figsize, sharex=True, sharey=False, constrained_layout=True
    )

    # pre-process raw data to plot
    sig_avgs = []
    ref_avgs = []
    # add roi data
    roi_avg_sig = np.nanmean(np.nanmean(sig, axis=2), axis=1)
    roi_avg_ref = np.nanmean(np.nanmean(ref, axis=2), axis=1)
    sig_avgs.append(roi_avg_sig)
    ref_avgs.append(roi_avg_ref)
    # add single pixel check
    pixel_sig = sig[:, options[&#34;single_pixel_check&#34;][1], options[&#34;single_pixel_check&#34;][0]]
    pixel_ref = ref[:, options[&#34;single_pixel_check&#34;][1], options[&#34;single_pixel_check&#34;][0]]
    sig_avgs.append(pixel_sig)
    ref_avgs.append(pixel_ref)
    # add AOI data
    for i, AOI in enumerate(AOIs):
        sig_avg = np.nanmean(np.nanmean(sig[:, AOI[0], AOI[1]], axis=2), axis=1)
        ref_avg = np.nanmean(np.nanmean(ref[:, AOI[0], AOI[1]], axis=2), axis=1)
        sig_avgs.append(sig_avg)
        ref_avgs.append(ref_avg)

    # plot sig, ref data as first column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):

        # plot sig
        axs[i, 0].plot(
            sweep_list,
            sig,
            label=&#34;sig&#34;,
            c=&#34;blue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;cornflowerblue&#34;,
            mec=&#34;mediumblue&#34;,
        )
        # plot ref
        axs[i, 0].plot(
            sweep_list,
            ref,
            label=&#34;ref&#34;,
            c=&#34;green&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;limegreen&#34;,
            mec=&#34;darkgreen&#34;,
        )

        axs[i, 0].legend()
        axs[i, 0].grid(True)
        if not i:
            axs[i, 0].set_title(&#34;ROI avg&#34;)
        elif i == 1:
            axs[i, 0].set_title(&#34;Single Pixel Check&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]})
        else:
            axs[i, 0].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]}
            )
        axs[i, 0].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 0].set_xlabel(&#34;Sweep parameter&#34;)

    # plot normalisation as second column
    for i, (sig, ref) in enumerate(zip(sig_avgs, ref_avgs)):
        axs[i, 1].plot(
            sweep_list,
            1 + (sig - ref) / (sig + ref),
            label=&#34;subtraction&#34;,
            c=&#34;firebrick&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;lightcoral&#34;,
            mec=&#34;maroon&#34;,
        )
        axs[i, 1].plot(
            sweep_list,
            sig / ref,
            label=&#34;division&#34;,
            c=&#34;cadetblue&#34;,
            ls=&#34;dashed&#34;,
            marker=&#34;o&#34;,
            mfc=&#34;powderblue&#34;,
            mec=&#34;darkslategrey&#34;,
        )

        axs[i, 1].legend()
        axs[i, 1].grid(True)
        if not i:
            axs[i, 1].set_title(&#34;ROI avg - Normalisation&#34;)
        elif i == 1:
            axs[i, 1].set_title(
                &#34;Single Pixel Check - Normalisation&#34;, fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]}
            )
        else:
            axs[i, 1].set_title(
                &#34;AOI &#34; + str(i - 1) + &#34; avg - Normalisation&#34;,
                fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
            )
        axs[i, 1].set_ylabel(&#34;PL (a.u.)&#34;)
    axs[-1, 1].set_xlabel(
        &#34;Sweep parameter&#34;
    )  # this is meant to be less indented than the line above

    high_res_xdata = np.linspace(
        np.min(fit_result_collection_lst[0].roi_avg_fit_result.sweep_list),
        np.max(fit_result_collection_lst[0].roi_avg_fit_result.sweep_list),
        10000,
    )

    # loop of fit backends first
    for fit_backend_number, fit_backend_fit_result in enumerate(fit_result_collection_lst):
        fit_backend_name = fit_backend_fit_result.fit_backend

        fit_params_lst = [
            fit_backend_fit_result.roi_avg_fit_result.best_params,
            fit_backend_fit_result.single_pixel_fit_result,
            *fit_backend_fit_result.AOI_fit_results_lst,
        ]
        # now plot fits as third column
        for i, (fit_param_ar, sig, ref) in enumerate(zip(fit_params_lst, sig_avgs, ref_avgs)):
            if not options[&#34;used_ref&#34;]:
                sig_norm = sig
            elif options[&#34;normalisation&#34;] == &#34;div&#34;:
                sig_norm = sig / ref
            elif options[&#34;normalisation&#34;] == &#34;sub&#34;:
                sig_norm = 1 + (sig - ref) / (sig + ref)

            best_fit_ydata = fit_model(fit_param_ar, high_res_xdata)
            roi_fit_ydata = fit_model(
                fit_backend_fit_result.roi_avg_fit_result.best_params, high_res_xdata
            )

            # this is the first loop -&gt; plot raw data, add titles
            if not fit_backend_number:

                # raw data
                axs[i, 2].plot(
                    sweep_list,
                    sig_norm,
                    label=f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;,
                    ls=&#34;&#34;,
                    marker=&#34;o&#34;,
                    ms=3.5,
                    mfc=&#34;goldenrod&#34;,
                    mec=&#34;k&#34;,
                )
                if not i:
                    axs[i, 2].set_title(&#34;ROI avg - Fit&#34;)
                elif i == 1:
                    axs[i, 2].set_title(
                        &#34;Single Pixel Check - Fit&#34;,
                        fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][0]},
                    )
                else:
                    axs[i, 2].set_title(
                        &#34;AOI &#34; + str(i - 1) + &#34; avg - Fit&#34;,
                        fontdict={&#34;color&#34;: options[&#34;AOI_colors&#34;][i - 1]},
                    )
            # roi avg fit (as comparison)
            if i:
                axs[i, 2].plot(
                    high_res_xdata,
                    roi_fit_ydata,
                    label=f&#34;ROI avg fit - {fit_backend_name}&#34;,
                    ls=&#34;dashed&#34;,
                    c=options[&#34;fit_backend_colors&#34;][fit_backend_name][&#34;aoi_roi_fit_linecolor&#34;],
                )
            # best fit
            axs[i, 2].plot(
                high_res_xdata,
                best_fit_ydata,
                label=f&#34;fit - {fit_backend_name}&#34;,
                ls=&#34;dashed&#34;,
                c=options[&#34;fit_backend_colors&#34;][fit_backend_name][&#34;aoi_best_fit_linecolor&#34;],
            )

            axs[i, 2].legend()
            axs[i, 2].grid(True)
            axs[i, 2].set_ylabel(&#34;PL (a.u.)&#34;)

    axs[-1, 2].set_xlabel(&#34;Sweep parameter&#34;)  # this is meant to be less indented than line above

    # currently not saving any of the data from this plot (not sure what the user would ever want)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;AOI_spectra_fits.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_ROI_PL_image"><code class="name flex">
<span>def <span class="ident">plot_ROI_PL_image</span></span>(<span>options, PL_image)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots full PL image with ROI region annotated.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>PL_image</code></strong> :&ensp;<code>np array, 2D</code></dt>
<dd>Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
not cut down to ROI.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ROI_PL_image(options, PL_image):
    &#34;&#34;&#34;
    Plots full PL image with ROI region annotated.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    PL_image : np array, 2D
        Summed counts across sweep_value (affine) axis (i.e. 0th axis). Reshaped, rebinned but
        not cut down to ROI.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    c_map = options[&#34;colormaps&#34;][&#34;PL_images&#34;]
    c_range = plot_common._get_colormap_range(
        options[&#34;colormap_range_dicts&#34;][&#34;PL_images&#34;], PL_image
    )

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_common.plot_image_on_ax(
        fig,
        ax,
        options,
        PL_image,
        &#34;PL - ROI&#34;,
        c_map,
        c_range,
        &#34;Counts&#34;,
    )

    if options[&#34;annotate_image_regions&#34;]:
        _annotate_ROI_image(options, ax)

    if options[&#34;save_plots&#34;]:
        fig.savefig(options[&#34;output_dir&#34;] / (&#34;PL - ROI.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_ROI_avg_fits"><code class="name flex">
<span>def <span class="ident">plot_ROI_avg_fits</span></span>(<span>options, backend_ROI_results_lst)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots fit of spectrum averaged across ROI, as well as corresponding residual values.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>backend_ROI_results_lst</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>Format: (fit_backend, <code><a title="QDMPy.fit._shared.ROIAvgFitResult" href="../fit/_shared.html#QDMPy.fit._shared.ROIAvgFitResult">ROIAvgFitResult</a></code> objects), for each fit_backend</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ROI_avg_fits(options, backend_ROI_results_lst):
    &#34;&#34;&#34;
    Plots fit of spectrum averaged across ROI, as well as corresponding residual values.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    backend_ROI_results_lst : list of tuples
        Format: (fit_backend, `QDMPy.fit._shared.ROIAvgFitResult` objects), for each fit_backend

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;
    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
    figsize[0] *= 2
    figsize[1] *= 1.5

    fig = plt.figure(
        figsize=figsize, constrained_layout=False
    )  # constrained doesn&#39;t work well here?
    # xstart, ystart, xend, yend [units are fraction of the image frame, from bottom left corner]
    spectrum_frame = fig.add_axes((0.1, 0.3, 0.8, 0.6))

    lspec_names = []
    lspec_lines = []

    spectrum_frame.plot(
        backend_ROI_results_lst[0].sweep_list,
        backend_ROI_results_lst[0].pl_roi,
        label=f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;,
        ls=&#34; &#34;,
        marker=&#34;o&#34;,
        mfc=&#34;w&#34;,
        mec=&#34;firebrick&#34;,
    )
    lspec_names.append(f&#34;raw data ({options[&#39;normalisation&#39;]})&#34;)
    lspec_lines.append(
        Line2D(
            [0],
            [0],
            ls=&#34; &#34;,
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=&#34;firebrick&#34;,
        )
    )

    high_res_sweep_list = np.linspace(
        np.min(backend_ROI_results_lst[0].sweep_list),
        np.max(backend_ROI_results_lst[0].sweep_list),
        10000,
    )
    high_res_init_fit = backend_ROI_results_lst[0].fit_model(
        backend_ROI_results_lst[0].init_param_guess, high_res_sweep_list
    )
    spectrum_frame.plot(
        high_res_sweep_list,
        high_res_init_fit,
        linestyle=(0, (1, 1)),
        label=&#34;init guess&#34;,
        c=&#34;darkgreen&#34;,
    )
    lspec_names.append(&#34;init guess&#34;)
    lspec_lines.append(
        Line2D(
            [0],
            [0],
            linestyle=(0, (1, 1)),
            c=&#34;darkgreen&#34;,
        )
    )

    spectrum_frame.set_xticklabels([])  # remove from first frame

    spectrum_frame.grid()
    spectrum_frame.set_ylabel(&#34;PL (a.u.)&#34;)

    # residual plot
    residual_frame = fig.add_axes((0.1, 0.1, 0.8, 0.2))

    lresid_names = []
    lresid_lines = []

    residual_frame.grid()

    residual_frame.set_xlabel(&#34;Sweep parameter&#34;)
    residual_frame.set_ylabel(&#34;Fit - data (a.u.)&#34;)

    for res in backend_ROI_results_lst:

        # ODMR spectrum_frame
        high_res_best_fit = res.fit_model(res.best_params, high_res_sweep_list)

        spectrum_frame.plot(
            high_res_sweep_list,
            high_res_best_fit,
            linestyle=&#34;--&#34;,
            label=f&#34;{res.fit_backend} best fit&#34;,
            c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;roifit_linecolor&#34;],
        )
        lspec_names.append(f&#34;{res.fit_backend} best fit&#34;)
        lspec_lines.append(
            Line2D(
                [0],
                [0],
                linestyle=&#34;--&#34;,
                c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;roifit_linecolor&#34;],
            )
        )

        residual_xdata = res.sweep_list
        residual_ydata = res.fit_model(res.best_params, res.sweep_list) - res.pl_roi

        residual_frame.plot(
            residual_xdata,
            residual_ydata,
            label=f&#34;{res.fit_backend} residual&#34;,
            ls=&#34;dashed&#34;,
            c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            mec=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
        )
        lresid_names.append(f&#34;{res.fit_backend} residual&#34;)
        lresid_lines.append(
            Line2D(
                [0],
                [0],
                ls=&#34;dashed&#34;,
                c=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
                marker=&#34;o&#34;,
                mfc=&#34;w&#34;,
                mec=options[&#34;fit_backend_colors&#34;][res.fit_backend][&#34;residual_linecolor&#34;],
            )
        )

        res.savejson(f&#34;ROI_avg_fit_{res.fit_backend}.json&#34;, options[&#34;data_dir&#34;])

    # https://jdhao.github.io/2018/01/23/matplotlib-legend-outside-of-axes/
    # https://matplotlib.org/3.2.1/gallery/lines_bars_and_markers/linestyles.html
    legend_names = lspec_names.copy()
    legend_names.extend(lresid_names)

    legend_lines = lspec_lines.copy()
    legend_lines.extend(lresid_lines)

    spectrum_frame.legend(
        legend_lines,
        legend_names,
        loc=&#34;lower left&#34;,
        bbox_to_anchor=(0.0, 1.01),
        fontsize=&#34;medium&#34;,
        ncol=len(legend_names),
        borderaxespad=0,
        frameon=False,
    )
    fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    # spectrum_frame.legend()

    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;] / (f&#34;ROI_avg_fit_{res.fit_backend}.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_param_image"><code class="name flex">
<span>def <span class="ident">plot_param_image</span></span>(<span>options, fit_model, pixel_fit_params, param_name, param_number=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots an image corresponding to a single parameter in pixel_fit_params.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>fit_model</code></strong> :&ensp;<code><a title="QDMPy.fit._models.FitModel" href="../fit/_models.html#QDMPy.fit._models.FitModel">FitModel</a></code></dt>
<dd>Model we're fitting to.</dd>
<dt><strong><code>pixel_fit_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary, key: param_keys, val: image (2D) of param values across FOV.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of parameter you want to plot, e.g. 'fwhm'. Can also be 'residual'.</dd>
</dl>
<h2 id="optional-arguments">Optional Arguments</h2>
<p>param_number : int
Which version of the parameter you want. I.e. there might be 8 independent parameters
in the fit model called 'pos', each labeled 'pos_0', 'pos_1' etc. Default: 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_param_image(options, fit_model, pixel_fit_params, param_name, param_number=0):
    &#34;&#34;&#34;
    Plots an image corresponding to a single parameter in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.


    Optional arguments
    ------------------
    param_number : int
        Which version of the parameter you want. I.e. there might be 8 independent parameters
        in the fit model called &#39;pos&#39;, each labeled &#39;pos_0&#39;, &#39;pos_1&#39; etc. Default: 0.


    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    image = pixel_fit_params[param_name + &#34;_&#34; + str(param_number)]

    if param_name == &#34;residual&#34;:
        c_range = plot_common._get_colormap_range(
            options[&#34;colormap_range_dicts&#34;][&#34;residual_images&#34;], image
        )
        c_map = options[&#34;colormaps&#34;][&#34;residual_images&#34;]
    else:
        c_range = plot_common._get_colormap_range(
            options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image
        )
        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]
    c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

    fig, ax = plt.subplots(constrained_layout=True)

    fig, ax = plot_common.plot_image_on_ax(
        fig, ax, options, image, param_name + &#34;_&#34; + str(param_number), c_map, c_range, c_label
    )

    np.savetxt(options[&#34;data_dir&#34;] / (param_name + &#34;_&#34; + str(param_number) + &#34;.txt&#34;), image)
    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;]
            / (param_name + &#34;_&#34; + str(param_number) + &#34;.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_param_images"><code class="name flex">
<span>def <span class="ident">plot_param_images</span></span>(<span>options, fit_model, pixel_fit_params, param_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots images for all independent versions of a single parameter type in pixel_fit_params.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>fit_model</code></strong> :&ensp;<code><a title="QDMPy.fit._models.FitModel" href="../fit/_models.html#QDMPy.fit._models.FitModel">FitModel</a></code></dt>
<dd>Model we're fitting to.</dd>
<dt><strong><code>pixel_fit_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary, key: param_keys, val: image (2D) of param values across FOV.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of parameter you want to plot, e.g. 'fwhm'. Can also be 'residual'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_param_images(options, fit_model, pixel_fit_params, param_name):
    &#34;&#34;&#34;
    Plots images for all independent versions of a single parameter type in pixel_fit_params.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.

    Returns
    -------
    fig : matplotlib Figure object
    &#34;&#34;&#34;

    # if no fit completed
    if pixel_fit_params is None:
        warnings.warn(
            &#34;&#39;pixel_fit_params&#39; arg to function &#39;plot_param_images&#39; is &#39;None&#39;.\n&#34;
            + &#34;Probably no pixel fitting completed.&#34;  # noqa: W503
        )
        return None

    # plot 2 columns wide, as many rows as required

    # first get keys we need
    our_keys = []
    for key in pixel_fit_params:
        if key.startswith(param_name):
            our_keys.append(key)

    # this is an inner function so no one uses it elsewhere/protect namespace
    def param_sorter(param):
        strings = param.split(&#34;_&#34;)  # e.g. &#34;amp_exp_2&#34; -&gt; [&#34;amp&#34;, &#34;exp&#34;, &#34;2&#34;]
        # all we need here is the number at the end actually
        # param_name_split = strings[:-1]  # list of &#39;words&#39;, e.g. [&#34;amp&#34;, &#34;exp&#34;]
        num = strings[-1]  # grab the number e.g. &#34;2
        return int(num)

    # sort based on number (just in case)
    our_keys.sort(key=param_sorter)
    nk = len(our_keys)

    if nk == 1:
        # just one image, so plot normally
        fig = plot_param_image(options, fit_model, pixel_fit_params, param_name, 0)
    else:
        if nk &lt;= 8:
            num_columns = 4
            num_rows = 2
        else:
            num_columns = 2
            num_rows = math.ceil(nk / 2)

        figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()
        figsize[0] *= num_columns
        figsize[1] *= num_rows

        figsize[0] *= 3 / 4
        figsize[1] *= 3 / 4

        fig, axs = plt.subplots(
            num_rows,
            num_columns,
            figsize=figsize,
            sharex=False,
            sharey=False,
            constrained_layout=True,
        )

        c_map = options[&#34;colormaps&#34;][&#34;param_images&#34;]

        # plot 8-lorentzian peaks in a more helpful way
        if nk &lt;= 8 and any([f.startswith(&#34;lorentzian&#34;) for f in options[&#34;fit_functions&#34;]]):
            param_nums = []  # [0, 1, 2, 3, 7, 6, 5, 4] etc.
            param_nums.extend(list(range(nk // 2)))
            if nk % 2:
                param_nums.append(nk // 2 + 1)
            param_nums.extend(list(range(nk - 1, (nk - 1) // 2, -1)))  # range(start, stop, step)
            param_axis_iterator = zip(param_nums, axs.flatten())
        # otherwise plot in a more conventional order
        else:
            param_axis_iterator = enumerate(axs.flatten())

        for param_number, ax in param_axis_iterator:

            param_key = param_name + &#34;_&#34; + str(param_number)

            try:
                image_data = pixel_fit_params[param_key]
            except KeyError:
                # we have one too many axes (i.e. 7 params, 8 subplots), delete the axs
                fig.delaxes(ax)
                break

            c_range = plot_common._get_colormap_range(
                options[&#34;colormap_range_dicts&#34;][&#34;param_images&#34;], image_data
            )
            c_label = fit_models.get_param_unit(fit_model, param_name, param_number)

            plot_common.plot_image_on_ax(
                fig,
                ax,
                options,
                image_data,
                param_key,
                c_map,
                c_range,
                c_label,
            )

        if options[&#34;save_plots&#34;]:
            fig.savefig(options[&#34;output_dir&#34;] / (param_name + &#34;.&#34; + options[&#34;save_fig_type&#34;]))

    return fig</code></pre>
</details>
</dd>
<dt id="QDMPy.plot.fits.plot_params_flattened"><code class="name flex">
<span>def <span class="ident">plot_params_flattened</span></span>(<span>options, fit_model, pixel_fit_params, roi_avg_fit_result, param_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare pixel fits against flattened pixels: initial guess vs roi fit vs fit result.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Generic options dict holding all the user options.</dd>
<dt><strong><code>fit_model</code></strong> :&ensp;<code><a title="QDMPy.fit._models.FitModel" href="../fit/_models.html#QDMPy.fit._models.FitModel">FitModel</a></code></dt>
<dd>Model we're fitting to.</dd>
<dt><strong><code>pixel_fit_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary, key: param_keys, val: image (2D) of param values across FOV.</dd>
<dt><strong><code>roi_avg_fit_result</code></strong></dt>
<dd><code><a title="QDMPy.fit._shared.ROIAvgFitResult" href="../fit/_shared.html#QDMPy.fit._shared.ROIAvgFitResult">ROIAvgFitResult</a></code> object.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of parameter you want to plot, e.g. 'fwhm'. Can also be 'residual'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib Figure object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_params_flattened(options, fit_model, pixel_fit_params, roi_avg_fit_result, param_name):
    &#34;&#34;&#34;
    Compare pixel fits against flattened pixels: initial guess vs roi fit vs fit result.

    Arguments
    ---------
    options : dict
        Generic options dict holding all the user options.

    fit_model : `QDMPy.fit._models.FitModel`
        Model we&#39;re fitting to.

    pixel_fit_params : dict
        Dictionary, key: param_keys, val: image (2D) of param values across FOV.

    roi_avg_fit_result
        `QDMPy.fit._shared.ROIAvgFitResult` object.

    param_name : str
        Name of parameter you want to plot, e.g. &#39;fwhm&#39;. Can also be &#39;residual&#39;.

    Returns
    -------
    fig : matplotlib Figure object

    &#34;&#34;&#34;

    # initial guess vs roi fit vs pixel fit

    param_keys = sorted([p for p in pixel_fit_params if p.startswith(param_name)])

    figsize = mpl.rcParams[&#34;figure.figsize&#34;].copy()

    height = len(param_keys)
    width = 1
    figsize[0] *= 2  # make some extra space...
    figsize[1] = figsize[1] * height / 2 if height &gt; 1 else figsize[1]

    fig, axs = plt.subplots(height, width, sharex=True, figsize=figsize, constrained_layout=True)
    # axs indexed: axs[row, col] (n_cols = 1 here, so index linearly)
    if type(axs) is not np.ndarray:
        axs = np.array([axs])

    if param_name == &#34;residual&#34;:
        param_guesses = [
            fit_model.residuals_scipyfit(
                roi_avg_fit_result.init_param_guess,
                roi_avg_fit_result.sweep_list,
                roi_avg_fit_result.pl_roi,
            ).sum()
        ]

        param_roi_fits = [
            fit_model.residuals_scipyfit(
                roi_avg_fit_result.best_params,
                roi_avg_fit_result.sweep_list,
                roi_avg_fit_result.pl_roi,
            ).sum()
        ]
    else:
        param_guesses = []
        param_roi_fits = []
        for fn_obj in fit_model.fn_chain:
            for param_num, param_root in enumerate(fn_obj.param_defn):
                if param_root == param_name:
                    param_guesses.append(
                        roi_avg_fit_result.init_param_guess[
                            fn_obj.this_fn_param_indices[param_num]
                        ]
                    )
                    param_roi_fits.append(
                        roi_avg_fit_result.best_params[fn_obj.this_fn_param_indices[param_num]]
                    )

    fig.suptitle(param_name, fontsize=16)

    axs[-1].set_xlabel(&#34;Pixel # (flattened)&#34;)
    for ax in axs:
        ax.set_ylabel(fit_models.get_param_unit(fit_model, param_name, 0))
        ax.grid()

    # uses the default color cycle... i.e.:
    prop_cycle = plt.rcParams[&#34;axes.prop_cycle&#34;]
    colors = prop_cycle.by_key()[&#34;color&#34;]

    legend_names = [&#34;Initial guesses&#34;, &#34;ROI fits&#34;]
    # https://matplotlib.org/3.2.1/gallery/lines_bars_and_markers/linestyles.html
    custom_lines = [
        Line2D([0], [0], color=&#34;k&#34;, ls=(0, (1, 1)), lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2),
        Line2D([0], [0], color=&#34;k&#34;, ls=(0, (5, 1)), lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2),
    ]

    for i, guess in enumerate(param_guesses):
        axs[i].axhline(
            guess,
            ls=(0, (1, 1)),
            c=&#34;k&#34;,
            zorder=10,
            lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2,
        )

    for i, roi_fit in enumerate(param_roi_fits):
        axs[i].axhline(
            roi_fit,
            ls=(0, (5, 1)),
            lw=mpl.rcParams[&#34;lines.linewidth&#34;] * 2,
            c=&#34;k&#34;,
            zorder=5,
        )

    for i, (param_key, color) in enumerate(zip(param_keys, colors)):
        axs[i].plot(
            pixel_fit_params[param_key].flatten(),
            label=param_key,
            marker=&#34;o&#34;,
            mfc=&#34;w&#34;,
            ms=mpl.rcParams[&#34;lines.markersize&#34;] // 2,
            mec=color,
            ls=&#34;&#34;,
        )
        legend_names.append(param_key)
        custom_lines.append(
            Line2D(
                [0],
                [0],
                marker=&#34;o&#34;,
                mfc=&#34;w&#34;,
                ms=mpl.rcParams[&#34;lines.markersize&#34;] * 2,
                mec=color,
                ls=&#34;&#34;,
            )
        )

    # https://jdhao.github.io/2018/01/23/matplotlib-legend-outside-of-axes/
    axs[0].legend(
        custom_lines,
        legend_names,
        loc=&#34;lower left&#34;,
        bbox_to_anchor=(0.0, 1.01),
        ncol=height + 2,
        borderaxespad=0,
        frameon=False,
        fontsize=&#34;medium&#34;,
    )

    if options[&#34;save_plots&#34;]:
        fig.savefig(
            options[&#34;output_dir&#34;] / (f&#34;{param_name}_fit_flattened.&#34; + options[&#34;save_fig_type&#34;])
        )

    return fig</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#functions">Functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QDMPy.plot" href="index.html">QDMPy.plot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="QDMPy.plot.fits._add_patch_rect" href="#QDMPy.plot.fits._add_patch_rect">_add_patch_rect</a></code></li>
<li><code><a title="QDMPy.plot.fits._annotate_AOI_image" href="#QDMPy.plot.fits._annotate_AOI_image">_annotate_AOI_image</a></code></li>
<li><code><a title="QDMPy.plot.fits._annotate_ROI_image" href="#QDMPy.plot.fits._annotate_ROI_image">_annotate_ROI_image</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_PL_images" href="#QDMPy.plot.fits.plot_AOI_PL_images">plot_AOI_PL_images</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_spectra" href="#QDMPy.plot.fits.plot_AOI_spectra">plot_AOI_spectra</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_AOI_spectra_fit" href="#QDMPy.plot.fits.plot_AOI_spectra_fit">plot_AOI_spectra_fit</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_ROI_PL_image" href="#QDMPy.plot.fits.plot_ROI_PL_image">plot_ROI_PL_image</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_ROI_avg_fits" href="#QDMPy.plot.fits.plot_ROI_avg_fits">plot_ROI_avg_fits</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_param_image" href="#QDMPy.plot.fits.plot_param_image">plot_param_image</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_param_images" href="#QDMPy.plot.fits.plot_param_images">plot_param_images</a></code></li>
<li><code><a title="QDMPy.plot.fits.plot_params_flattened" href="#QDMPy.plot.fits.plot_params_flattened">plot_params_flattened</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>