<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>QDMPy.hamiltonian._hamiltonians API documentation</title>
<meta name="description" content="The module holds Hamiltonian objects that will be fit to â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QDMPy.hamiltonian._hamiltonians</code></h1>
</header>
<section id="section-intro">
<p>The module holds Hamiltonian objects that will be fit to.</p>
<h2 id="classes">Classes</h2>
<ul>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz">ApproxBxyz</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Bxyz" href="#QDMPy.hamiltonian._hamiltonians.Bxyz">Bxyz</a></code></li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.get_param_defn" href="#QDMPy.hamiltonian._hamiltonians.get_param_defn">get_param_defn()</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.get_param_odict" href="#QDMPy.hamiltonian._hamiltonians.get_param_odict">get_param_odict()</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
The module holds Hamiltonian objects that will be fit to.

Classes
-------
 - `QDMPy.hamiltonian._hamiltonians.Hamiltonian`
 - `QDMPy.hamiltonian._hamiltonians.ApproxBxyz`
 - `QDMPy.hamiltonian._hamiltonians.Bxyz`

Functions
---------
 - `QDMPy.hamiltonian._hamiltonians.get_param_defn`
 - `QDMPy.hamiltonian._hamiltonians.get_param_odict`
&#34;&#34;&#34;

__author__ = &#34;Sam Scholten&#34;
__pdoc__ = {
    &#34;QDMPy.hamiltonian._hamiltonians.Hamiltonian&#34;: True,
    &#34;QDMPy.hamiltonian._hamiltonians.ApproxBxyz&#34;: True,
    &#34;QDMPy.hamiltonian._hamiltonians.Bxyz&#34;: True,
    &#34;QDMPy.hamiltonian._hamiltonians.get_param_defn&#34;: True,
    &#34;QDMPy.hamiltonian._hamiltonians.get_param_odict&#34;: True,
}

# ============================================================================

import numpy as np
import numpy.linalg as LA
from collections import OrderedDict

# ============================================================================


class Hamiltonian:

    param_defn = []
    param_units = {}
    jac_defined = False

    def __init__(self, chooser_obj, unv_frames):
        &#34;&#34;&#34;
        chooser_obj is used on __call__ and measured_data to return an array
        of only the required parts.
        &#34;&#34;&#34;
        self.chooser_obj = chooser_obj
        self.unv_frames = unv_frames
        self.unvs = unv_frames[:, 2, :].copy()  # i.e. z axis of each nv ref. frame in lab frame

    # =================================

    def __call__(self, param_ar):
        &#34;&#34;&#34;
        Evaluates Hamiltonian for given parameter values.

        Arguments
        ---------
        param_ar : np array, 1D
            Array of hamiltonian parameters fed in.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;You MUST override __call__, check your spelling.&#34;)

    # =================================

    def grad_fn(self, param_ar):
        &#34;&#34;&#34;
        Return jacobian, shape: (len(bnvs/freqs), len(param_ar))
        Each column is a partial derivative, with respect to each param in param_ar
            (i.e. rows, or first index, is indexing though the bnvs/freqs.)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No grad_fn defined for this Hamiltonian.&#34;)

    # =================================

    def residuals_scipyfit(self, param_ar, measured_data):
        &#34;&#34;&#34;
        Evaluates residual: fit model - measured_data. Returns a vector!
        Measured data must be a np array (of the same shape that __call__ returns),
        i.e. freqs, or bnvs.
        &#34;&#34;&#34;
        return self.chooser_obj(self.__call__(param_ar)) - self.chooser_obj(measured_data)

    # =================================

    def jacobian_scipyfit(self, param_ar, measured_data):
        &#34;&#34;&#34;Evaluates (analytic) jacobian of ham in format expected by scipy least_squares.&#34;&#34;&#34;

        # need to take out rows (first index) according to chooser_obj.
        keep_rows = self.chooser_obj([i for i in range(len(measured_data))])
        delete_rows = [r for r in range(len(measured_data)) if r not in keep_rows]
        return np.delete(self.grad_fn(param_ar), delete_rows, axis=0)

    # =================================

    def jacobian_defined(self):
        return self.jac_defined


# ============================================================================


def get_param_defn(hamiltonian):
    return hamiltonian.param_defn


# ====================================


def get_param_odict(hamiltonian):
    &#34;&#34;&#34;
    get ordered dict of key: param_key (param_name), val: param_unit for all parameters in ham
    &#34;&#34;&#34;
    return OrderedDict(hamiltonian.param_units)


# ====================================


def get_param_unit(hamiltonian, param_key):
    &#34;&#34;&#34;
    Get unit for a given param_key
    &#34;&#34;&#34;
    if param_key == &#34;residual_field&#34;:
        return &#34;Error: sum( || residual(params) || ) over bnvs/freqs (a.u.)&#34;
    param_dict = get_param_odict(hamiltonian)
    return param_dict[param_key]


# ============================================================================


class ApproxBxyz(Hamiltonian):
    r&#34;&#34;&#34;
    Diagonal Hamiltonian approximation. To calculate the magnetic field only fields aligned with
    the NV are considered and thus a simple dot product can be used.

    Fits to bnvs rather than frequencies, i.e.:
    $$ \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} $$
    Where overline denotes qst-order tensor (vector), double overline denotes 2nd-order tensor
    (matrix).
    &#34;&#34;&#34;

    param_defn = [&#34;Bx&#34;, &#34;By&#34;, &#34;Bz&#34;]
    param_units = {
        &#34;Bx&#34;: &#34;Magnetic field, Bx (G)&#34;,
        &#34;By&#34;: &#34;Magnetic field, By (G)&#34;,
        &#34;Bz&#34;: &#34;Magnetic field, Bz (G)&#34;,
    }
    jac_defined = True

    def __call__(self, param_ar):
        r&#34;&#34;&#34;
        $$ \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} $$
        Where overline denotes qst-order tensor (vector), double overline denotes 2nd-order tensor
        (matrix).
        Fit to bnv rather than frequency positions.

        param_ar = [Bx, By, Bz]
        &#34;&#34;&#34;
        return np.dot(self.unvs, param_ar)

    def grad_fn(self, param_ar):
        return self.unvs
        # J = np.empty((4, 3))  # size: (len(bnvs), len(param_ar)), both known ahead of time.
        # J[:, 0] = self.unvs[:, 0]
        # J[:, 1] = self.unvs[:, 1]
        # J[:, 2] = self.unvs[:, 2]
        # return J
        # i.e. equiv. to:
        # for bnv in range(4):
        #     J[bnv, 0] = self.unvs[bnv][0]  # i.e. ith NV orientation (bnv), x component
        #     J[bnv, 1] = self.unvs[bnv][1]  # y component
        #     J[bnv, 2] = self.unvs[bnv][2]  # z component
        # should be rather obvious from __call__


# ============================================================================


class Bxyz(Hamiltonian):
    r&#34;&#34;&#34;
    $$ H_i = D S_{Z_i}^{2} + \gamma_{\rm{NV}} \bf{B} \cdot \bf{S} $$

    where \( {\bf S}_i = (S_{X_i}, S_{Y_i}, S_{Z_i}) \) are the spin-1 operators.
    Here \( (X_i, Y_i, Z_i) \) is the coordinate system of the NV and \( i = 1,2,3,4 \) labels
    each NV orientation with respect to the lab frame.
    &#34;&#34;&#34;

    param_defn = [&#34;D&#34;, &#34;Bx&#34;, &#34;By&#34;, &#34;Bz&#34;]
    param_units = {
        &#34;D&#34;: &#34;Zero field splitting (MHz)&#34;,
        &#34;Bx&#34;: &#34;Magnetic field, Bx (G)&#34;,
        &#34;By&#34;: &#34;Magnetic field, By (G)&#34;,
        &#34;Bz&#34;: &#34;Magnetic field, Bz (G)&#34;,
    }
    jac_defined = False

    def __call__(self, param_ar):
        &#34;&#34;&#34;
        Hamiltonain of the NV spin using only the zero field splitting D and the magnetic field
        bxyz. Takes the fit_params in the order [D, bx, by, bz] and returns the nv frequencies.

        The spin operators need to be rotated to the NV reference frame. This is achieved
        by projecting the magnetic field onto the unv frame.

        i.e. we use the spin operatores in the NV frame, the unvs in the NV frame,
        and thus project the magnetic field into this frame (from the lab frame) to determine
        the nv frequencies (eigenvalues of hamiltonian).
        &#34;&#34;&#34;
        from QDMPy.constants import S_MAT_X, S_MAT_Y, S_MAT_Z, GAMMA

        nv_frequencies = np.zeros(8)
        # D, Bx, By, Bz = param_ar

        Hzero = param_ar[0] * (S_MAT_Z * S_MAT_Z)
        for i in range(4):
            bx_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 0, :])
            by_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 1, :])
            bz_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 2, :])

            HB = GAMMA * (
                bx_proj_onto_unv * S_MAT_X
                + by_proj_onto_unv * S_MAT_Y
                + bz_proj_onto_unv * S_MAT_Z
            )
            freq, _ = LA.eig(Hzero + HB)
            freq = np.sort(np.real(freq))
            # freqs: ms=0, ms=+-1 -&gt; transition freq is delta
            nv_frequencies[i] = np.real(freq[1] - freq[0])
            nv_frequencies[7 - i] = np.real(freq[2] - freq[0])
        return nv_frequencies

    # this method didn&#39;t work :(
    # def grad_fn(self, param_ar):

    # method here: do partial before calculating eigenvalues

    # from QDMPy.constants import S_MAT_X, S_MAT_Y, S_MAT_Z, GAMMA

    # J = np.empty((8, 4))  # shape: num freqs, num params

    # # p equiv. to D, Bx, By, Bz
    # for p in range(4):
    #     if not p:  # sort out D
    #         dH = S_MAT_Z * S_MAT_Z
    #         for i in range(4):
    #             df, _ = LA.eig(dH)
    #             df = np.sort(np.real(df))
    #             J[i, p] = np.real(df[1] - df[0])
    #             J[7 - i, p] = np.real(df[2] - df[0])
    #     else:  # sort out \vec{B}
    #         dparams = np.zeros(4)
    #         dparams[p] = 1  # no polynomials or anything like that so B_comp -&gt; 1, others -&gt; 0
    #         for i in range(4):

    #             dbx_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 0, :])
    #             dby_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 1, :])
    #             dbz_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 2, :])

    #             dH = GAMMA * (
    #                 dbx_proj_onto_unv * S_MAT_X
    #                 + dby_proj_onto_unv * S_MAT_Y
    #                 + dbz_proj_onto_unv * S_MAT_Z
    #             )
    #             df, _ = LA.eig(dH)
    #             df = np.sort(np.real(df))
    #             # freqs: ms=0, ms=+-1 -&gt; transition freq is delta
    #             J[i, p] = np.real(df[1] - df[0])
    #             J[7 - i, p] = np.real(df[2] - df[0])

    # return J</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.get_param_defn"><code class="name flex">
<span>def <span class="ident">get_param_defn</span></span>(<span>hamiltonian)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_defn(hamiltonian):
    return hamiltonian.param_defn</code></pre>
</details>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.get_param_odict"><code class="name flex">
<span>def <span class="ident">get_param_odict</span></span>(<span>hamiltonian)</span>
</code></dt>
<dd>
<div class="desc"><p>get ordered dict of key: param_key (param_name), val: param_unit for all parameters in ham</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_odict(hamiltonian):
    &#34;&#34;&#34;
    get ordered dict of key: param_key (param_name), val: param_unit for all parameters in ham
    &#34;&#34;&#34;
    return OrderedDict(hamiltonian.param_units)</code></pre>
</details>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.get_param_unit"><code class="name flex">
<span>def <span class="ident">get_param_unit</span></span>(<span>hamiltonian, param_key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get unit for a given param_key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_unit(hamiltonian, param_key):
    &#34;&#34;&#34;
    Get unit for a given param_key
    &#34;&#34;&#34;
    if param_key == &#34;residual_field&#34;:
        return &#34;Error: sum( || residual(params) || ) over bnvs/freqs (a.u.)&#34;
    param_dict = get_param_odict(hamiltonian)
    return param_dict[param_key]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.ApproxBxyz"><code class="flex name class">
<span>class <span class="ident">ApproxBxyz</span></span>
<span>(</span><span>chooser_obj, unv_frames)</span>
</code></dt>
<dd>
<div class="desc"><p>Diagonal Hamiltonian approximation. To calculate the magnetic field only fields aligned with
the NV are considered and thus a simple dot product can be used.</p>
<p>Fits to bnvs rather than frequencies, i.e.:
<span><span class="MathJax_Preview"> \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} </span><script type="math/tex; mode=display"> \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} </script></span>
Where overline denotes qst-order tensor (vector), double overline denotes 2nd-order tensor
(matrix).</p>
<p>chooser_obj is used on <strong>call</strong> and measured_data to return an array
of only the required parts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApproxBxyz(Hamiltonian):
    r&#34;&#34;&#34;
    Diagonal Hamiltonian approximation. To calculate the magnetic field only fields aligned with
    the NV are considered and thus a simple dot product can be used.

    Fits to bnvs rather than frequencies, i.e.:
    $$ \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} $$
    Where overline denotes qst-order tensor (vector), double overline denotes 2nd-order tensor
    (matrix).
    &#34;&#34;&#34;

    param_defn = [&#34;Bx&#34;, &#34;By&#34;, &#34;Bz&#34;]
    param_units = {
        &#34;Bx&#34;: &#34;Magnetic field, Bx (G)&#34;,
        &#34;By&#34;: &#34;Magnetic field, By (G)&#34;,
        &#34;Bz&#34;: &#34;Magnetic field, Bz (G)&#34;,
    }
    jac_defined = True

    def __call__(self, param_ar):
        r&#34;&#34;&#34;
        $$ \overline{\overline{B}}_{\rm NV} = overline{\overline{u}}_{\rm NV} \cdot \overline{B} $$
        Where overline denotes qst-order tensor (vector), double overline denotes 2nd-order tensor
        (matrix).
        Fit to bnv rather than frequency positions.

        param_ar = [Bx, By, Bz]
        &#34;&#34;&#34;
        return np.dot(self.unvs, param_ar)

    def grad_fn(self, param_ar):
        return self.unvs
        # J = np.empty((4, 3))  # size: (len(bnvs), len(param_ar)), both known ahead of time.
        # J[:, 0] = self.unvs[:, 0]
        # J[:, 1] = self.unvs[:, 1]
        # J[:, 2] = self.unvs[:, 2]
        # return J
        # i.e. equiv. to:
        # for bnv in range(4):
        #     J[bnv, 0] = self.unvs[bnv][0]  # i.e. ith NV orientation (bnv), x component
        #     J[bnv, 1] = self.unvs[bnv][1]  # y component
        #     J[bnv, 2] = self.unvs[bnv][2]  # z component
        # should be rather obvious from __call__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.jac_defined"><code class="name">var <span class="ident">jac_defined</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit">jacobian_scipyfit</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit">residuals_scipyfit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Bxyz"><code class="flex name class">
<span>class <span class="ident">Bxyz</span></span>
<span>(</span><span>chooser_obj, unv_frames)</span>
</code></dt>
<dd>
<div class="desc"><p><span><span class="MathJax_Preview"> H_i = D S_{Z_i}^{2} + \gamma_{\rm{NV}} \bf{B} \cdot \bf{S} </span><script type="math/tex; mode=display"> H_i = D S_{Z_i}^{2} + \gamma_{\rm{NV}} \bf{B} \cdot \bf{S} </script></span></p>
<p>where <span><span class="MathJax_Preview"> {\bf S}_i = (S_{X_i}, S_{Y_i}, S_{Z_i}) </span><script type="math/tex"> {\bf S}_i = (S_{X_i}, S_{Y_i}, S_{Z_i}) </script></span> are the spin-1 operators.
Here <span><span class="MathJax_Preview"> (X_i, Y_i, Z_i) </span><script type="math/tex"> (X_i, Y_i, Z_i) </script></span> is the coordinate system of the NV and <span><span class="MathJax_Preview"> i = 1,2,3,4 </span><script type="math/tex"> i = 1,2,3,4 </script></span> labels
each NV orientation with respect to the lab frame.</p>
<p>chooser_obj is used on <strong>call</strong> and measured_data to return an array
of only the required parts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bxyz(Hamiltonian):
    r&#34;&#34;&#34;
    $$ H_i = D S_{Z_i}^{2} + \gamma_{\rm{NV}} \bf{B} \cdot \bf{S} $$

    where \( {\bf S}_i = (S_{X_i}, S_{Y_i}, S_{Z_i}) \) are the spin-1 operators.
    Here \( (X_i, Y_i, Z_i) \) is the coordinate system of the NV and \( i = 1,2,3,4 \) labels
    each NV orientation with respect to the lab frame.
    &#34;&#34;&#34;

    param_defn = [&#34;D&#34;, &#34;Bx&#34;, &#34;By&#34;, &#34;Bz&#34;]
    param_units = {
        &#34;D&#34;: &#34;Zero field splitting (MHz)&#34;,
        &#34;Bx&#34;: &#34;Magnetic field, Bx (G)&#34;,
        &#34;By&#34;: &#34;Magnetic field, By (G)&#34;,
        &#34;Bz&#34;: &#34;Magnetic field, Bz (G)&#34;,
    }
    jac_defined = False

    def __call__(self, param_ar):
        &#34;&#34;&#34;
        Hamiltonain of the NV spin using only the zero field splitting D and the magnetic field
        bxyz. Takes the fit_params in the order [D, bx, by, bz] and returns the nv frequencies.

        The spin operators need to be rotated to the NV reference frame. This is achieved
        by projecting the magnetic field onto the unv frame.

        i.e. we use the spin operatores in the NV frame, the unvs in the NV frame,
        and thus project the magnetic field into this frame (from the lab frame) to determine
        the nv frequencies (eigenvalues of hamiltonian).
        &#34;&#34;&#34;
        from QDMPy.constants import S_MAT_X, S_MAT_Y, S_MAT_Z, GAMMA

        nv_frequencies = np.zeros(8)
        # D, Bx, By, Bz = param_ar

        Hzero = param_ar[0] * (S_MAT_Z * S_MAT_Z)
        for i in range(4):
            bx_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 0, :])
            by_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 1, :])
            bz_proj_onto_unv = np.dot(param_ar[1:4], self.unv_frames[i, 2, :])

            HB = GAMMA * (
                bx_proj_onto_unv * S_MAT_X
                + by_proj_onto_unv * S_MAT_Y
                + bz_proj_onto_unv * S_MAT_Z
            )
            freq, _ = LA.eig(Hzero + HB)
            freq = np.sort(np.real(freq))
            # freqs: ms=0, ms=+-1 -&gt; transition freq is delta
            nv_frequencies[i] = np.real(freq[1] - freq[0])
            nv_frequencies[7 - i] = np.real(freq[2] - freq[0])
        return nv_frequencies

    # this method didn&#39;t work :(
    # def grad_fn(self, param_ar):

    # method here: do partial before calculating eigenvalues

    # from QDMPy.constants import S_MAT_X, S_MAT_Y, S_MAT_Z, GAMMA

    # J = np.empty((8, 4))  # shape: num freqs, num params

    # # p equiv. to D, Bx, By, Bz
    # for p in range(4):
    #     if not p:  # sort out D
    #         dH = S_MAT_Z * S_MAT_Z
    #         for i in range(4):
    #             df, _ = LA.eig(dH)
    #             df = np.sort(np.real(df))
    #             J[i, p] = np.real(df[1] - df[0])
    #             J[7 - i, p] = np.real(df[2] - df[0])
    #     else:  # sort out \vec{B}
    #         dparams = np.zeros(4)
    #         dparams[p] = 1  # no polynomials or anything like that so B_comp -&gt; 1, others -&gt; 0
    #         for i in range(4):

    #             dbx_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 0, :])
    #             dby_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 1, :])
    #             dbz_proj_onto_unv = np.dot(dparams[1:4], self.unv_frames[i, 2, :])

    #             dH = GAMMA * (
    #                 dbx_proj_onto_unv * S_MAT_X
    #                 + dby_proj_onto_unv * S_MAT_Y
    #                 + dbz_proj_onto_unv * S_MAT_Z
    #             )
    #             df, _ = LA.eig(dH)
    #             df = np.sort(np.real(df))
    #             # freqs: ms=0, ms=+-1 -&gt; transition freq is delta
    #             J[i, p] = np.real(df[1] - df[0])
    #             J[7 - i, p] = np.real(df[2] - df[0])

    # return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.Bxyz.jac_defined"><code class="name">var <span class="ident">jac_defined</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Bxyz.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Bxyz.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit">jacobian_scipyfit</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit">residuals_scipyfit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian"><code class="flex name class">
<span>class <span class="ident">Hamiltonian</span></span>
<span>(</span><span>chooser_obj, unv_frames)</span>
</code></dt>
<dd>
<div class="desc"><p>chooser_obj is used on <strong>call</strong> and measured_data to return an array
of only the required parts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hamiltonian:

    param_defn = []
    param_units = {}
    jac_defined = False

    def __init__(self, chooser_obj, unv_frames):
        &#34;&#34;&#34;
        chooser_obj is used on __call__ and measured_data to return an array
        of only the required parts.
        &#34;&#34;&#34;
        self.chooser_obj = chooser_obj
        self.unv_frames = unv_frames
        self.unvs = unv_frames[:, 2, :].copy()  # i.e. z axis of each nv ref. frame in lab frame

    # =================================

    def __call__(self, param_ar):
        &#34;&#34;&#34;
        Evaluates Hamiltonian for given parameter values.

        Arguments
        ---------
        param_ar : np array, 1D
            Array of hamiltonian parameters fed in.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;You MUST override __call__, check your spelling.&#34;)

    # =================================

    def grad_fn(self, param_ar):
        &#34;&#34;&#34;
        Return jacobian, shape: (len(bnvs/freqs), len(param_ar))
        Each column is a partial derivative, with respect to each param in param_ar
            (i.e. rows, or first index, is indexing though the bnvs/freqs.)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No grad_fn defined for this Hamiltonian.&#34;)

    # =================================

    def residuals_scipyfit(self, param_ar, measured_data):
        &#34;&#34;&#34;
        Evaluates residual: fit model - measured_data. Returns a vector!
        Measured data must be a np array (of the same shape that __call__ returns),
        i.e. freqs, or bnvs.
        &#34;&#34;&#34;
        return self.chooser_obj(self.__call__(param_ar)) - self.chooser_obj(measured_data)

    # =================================

    def jacobian_scipyfit(self, param_ar, measured_data):
        &#34;&#34;&#34;Evaluates (analytic) jacobian of ham in format expected by scipy least_squares.&#34;&#34;&#34;

        # need to take out rows (first index) according to chooser_obj.
        keep_rows = self.chooser_obj([i for i in range(len(measured_data))])
        delete_rows = [r for r in range(len(measured_data)) if r not in keep_rows]
        return np.delete(self.grad_fn(param_ar), delete_rows, axis=0)

    # =================================

    def jacobian_defined(self):
        return self.jac_defined</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz">ApproxBxyz</a></li>
<li><a title="QDMPy.hamiltonian._hamiltonians.Bxyz" href="#QDMPy.hamiltonian._hamiltonians.Bxyz">Bxyz</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jac_defined"><code class="name">var <span class="ident">jac_defined</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>self, param_ar)</span>
</code></dt>
<dd>
<div class="desc"><p>Return jacobian, shape: (len(bnvs/freqs), len(param_ar))
Each column is a partial derivative, with respect to each param in param_ar
(i.e. rows, or first index, is indexing though the bnvs/freqs.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grad_fn(self, param_ar):
    &#34;&#34;&#34;
    Return jacobian, shape: (len(bnvs/freqs), len(param_ar))
    Each column is a partial derivative, with respect to each param in param_ar
        (i.e. rows, or first index, is indexing though the bnvs/freqs.)
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;No grad_fn defined for this Hamiltonian.&#34;)</code></pre>
</details>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_defined"><code class="name flex">
<span>def <span class="ident">jacobian_defined</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jacobian_defined(self):
    return self.jac_defined</code></pre>
</details>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit"><code class="name flex">
<span>def <span class="ident">jacobian_scipyfit</span></span>(<span>self, param_ar, measured_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates (analytic) jacobian of ham in format expected by scipy least_squares.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jacobian_scipyfit(self, param_ar, measured_data):
    &#34;&#34;&#34;Evaluates (analytic) jacobian of ham in format expected by scipy least_squares.&#34;&#34;&#34;

    # need to take out rows (first index) according to chooser_obj.
    keep_rows = self.chooser_obj([i for i in range(len(measured_data))])
    delete_rows = [r for r in range(len(measured_data)) if r not in keep_rows]
    return np.delete(self.grad_fn(param_ar), delete_rows, axis=0)</code></pre>
</details>
</dd>
<dt id="QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit"><code class="name flex">
<span>def <span class="ident">residuals_scipyfit</span></span>(<span>self, param_ar, measured_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates residual: fit model - measured_data. Returns a vector!
Measured data must be a np array (of the same shape that <strong>call</strong> returns),
i.e. freqs, or bnvs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residuals_scipyfit(self, param_ar, measured_data):
    &#34;&#34;&#34;
    Evaluates residual: fit model - measured_data. Returns a vector!
    Measured data must be a np array (of the same shape that __call__ returns),
    i.e. freqs, or bnvs.
    &#34;&#34;&#34;
    return self.chooser_obj(self.__call__(param_ar)) - self.chooser_obj(measured_data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
<li><a href="#functions">Functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QDMPy.hamiltonian" href="index.html">QDMPy.hamiltonian</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.get_param_defn" href="#QDMPy.hamiltonian._hamiltonians.get_param_defn">get_param_defn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.get_param_odict" href="#QDMPy.hamiltonian._hamiltonians.get_param_odict">get_param_odict</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.get_param_unit" href="#QDMPy.hamiltonian._hamiltonians.get_param_unit">get_param_unit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz">ApproxBxyz</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.jac_defined" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz.jac_defined">jac_defined</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_defn" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_units" href="#QDMPy.hamiltonian._hamiltonians.ApproxBxyz.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.hamiltonian._hamiltonians.Bxyz" href="#QDMPy.hamiltonian._hamiltonians.Bxyz">Bxyz</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Bxyz.jac_defined" href="#QDMPy.hamiltonian._hamiltonians.Bxyz.jac_defined">jac_defined</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Bxyz.param_defn" href="#QDMPy.hamiltonian._hamiltonians.Bxyz.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Bxyz.param_units" href="#QDMPy.hamiltonian._hamiltonians.Bxyz.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian">Hamiltonian</a></code></h4>
<ul class="two-column">
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jac_defined" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.jac_defined">jac_defined</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_defined" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_defined">jacobian_defined</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.jacobian_scipyfit">jacobian_scipyfit</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_defn" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_units" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.param_units">param_units</a></code></li>
<li><code><a title="QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit" href="#QDMPy.hamiltonian._hamiltonians.Hamiltonian.residuals_scipyfit">residuals_scipyfit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>