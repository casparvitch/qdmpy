<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>QDMPy.fit.models API documentation</title>
<meta name="description" content="This module defines the fit model used. We grab/use this regardless of fitting on cpu (scipy) or gpu etc â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QDMPy.fit.models</code></h1>
</header>
<section id="section-intro">
<p>This module defines the fit model used. We grab/use this regardless of fitting on cpu (scipy) or gpu etc.</p>
<p>Ensure any fit functions you define are added to the AVAILABLE_FNS module variable.
Try not to have overlapping parameter names in the same fit.</p>
<p>You do not need to import or access this module (it is used by other modules), but I have included
it in the documentation in case you would like to see the model implementation etc.</p>
<h2 id="classes">Classes</h2>
<ul>
<li><code><a title="QDMPy.fit.models.FitModel" href="#QDMPy.fit.models.FitModel">FitModel</a></code></li>
<li><code><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></code></li>
<li><code><a title="QDMPy.fit.models.Constant" href="#QDMPy.fit.models.Constant">Constant</a></code></li>
<li><code><a title="QDMPy.fit.models.Linear" href="#QDMPy.fit.models.Linear">Linear</a></code></li>
<li><code><a title="QDMPy.fit.models.Circular" href="#QDMPy.fit.models.Circular">Circular</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian" href="#QDMPy.fit.models.Gaussian">Gaussian</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_14" href="#QDMPy.fit.models.Gaussian_hyperfine_14">Gaussian_hyperfine_14</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_15" href="#QDMPy.fit.models.Gaussian_hyperfine_15">Gaussian_hyperfine_15</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian" href="#QDMPy.fit.models.Lorentzian">Lorentzian</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_14" href="#QDMPy.fit.models.Lorentzian_hyperfine_14">Lorentzian_hyperfine_14</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_15" href="#QDMPy.fit.models.Lorentzian_hyperfine_15">Lorentzian_hyperfine_15</a></code></li>
<li><code><a title="QDMPy.fit.models.Stretched_exponential" href="#QDMPy.fit.models.Stretched_exponential">Stretched_exponential</a></code></li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="QDMPy.fit.models.get_param_defn" href="#QDMPy.fit.models.get_param_defn">get_param_defn()</a></code></li>
<li><code><a title="QDMPy.fit.models.get_param_odict" href="#QDMPy.fit.models.get_param_odict">get_param_odict()</a></code></li>
<li><code><a title="QDMPy.fit.models.get_param_unit" href="#QDMPy.fit.models.get_param_unit">get_param_unit()</a></code></li>
</ul>
<h2 id="module-variables">Module Variables</h2>
<ul>
<li><code><a title="QDMPy.fit.models.AVAILABLE_FNS" href="#QDMPy.fit.models.AVAILABLE_FNS">AVAILABLE_FNS</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
This module defines the fit model used. We grab/use this regardless of fitting on cpu (scipy) or gpu etc.

Ensure any fit functions you define are added to the AVAILABLE_FNS module variable.
Try not to have overlapping parameter names in the same fit.

You do not need to import or access this module (it is used by other modules), but I have included
it in the documentation in case you would like to see the model implementation etc.

Classes
-------
 - `QDMPy.fit.models.FitModel`
 - `QDMPy.fit.models.FitFunc`
 - `QDMPy.fit.models.Constant`
 - `QDMPy.fit.models.Linear`
 - `QDMPy.fit.models.Circular`
 - `QDMPy.fit.models.Gaussian`
 - `QDMPy.fit.models.Gaussian_hyperfine_14`
 - `QDMPy.fit.models.Gaussian_hyperfine_15`
 - `QDMPy.fit.models.Lorentzian`
 - `QDMPy.fit.models.Lorentzian_hyperfine_14`
 - `QDMPy.fit.models.Lorentzian_hyperfine_15`
 - `QDMPy.fit.models.Stretched_exponential`

Functions
---------
 - `QDMPy.fit.models.get_param_defn`
 - `QDMPy.fit.models.get_param_odict`
 - `QDMPy.fit.models.get_param_unit`

Module variables
----------------
 - `QDMPy.fit.models.AVAILABLE_FNS`
&#34;&#34;&#34;

# ============================================================================

__author__ = &#34;Sam Scholten&#34;

# ============================================================================

import numpy as np
from numba import njit
from collections import OrderedDict

# ============================================================================


# ================================================================================================
# ================================================================================================
#
# FitModel Class
#
# ================================================================================================
# ================================================================================================


class FitModel:
    &#34;&#34;&#34;FitModel used to fit to data.&#34;&#34;&#34;

    def __init__(self, fit_functions):
        &#34;&#34;&#34;
        Arguments
        ---------
        fit_functions: dict
            Dict of functions to makeup the fit model, key: fitfunc name, val: number of
            independent copies of that fitfunc.
            format: {&#34;linear&#34;: 1, &#34;lorentzian&#34;: 8} etc., i.e. options[&#34;fit_functions&#34;]
        &#34;&#34;&#34;

        self.fit_functions = fit_functions

        fn_chain = []
        all_param_len = 0

        for fn_type, num_fns in fit_functions.items():
            for i in range(num_fns):
                next_fn = AVAILABLE_FNS[fn_type]  # NOTE: AVAILABLE_FNS defined at end of file
                next_fn_param_len = len(next_fn.param_defn)
                next_fn_param_indices = [all_param_len + i for i in range(next_fn_param_len)]
                all_param_len += next_fn_param_len
                fn_chain.append(next_fn(next_fn_param_indices))

        self.fn_chain = fn_chain

    # =================================

    def __call__(self, param_ar, sweep_vec):
        &#34;&#34;&#34;
        Evaluates fitmodel for given parameter values and sweep (affine) parameter values.

        Arguments
        ---------
        param_ar : np array, 1D
            Array of parameters fed into each fitfunc (these are what are fit by sc)

        sweep_vec : np array, 1D or number
            Affine parameter where the fit model is evaluated

        Returns
        -------
        Fit model evaluates at sweep_vec (output is same format as sweep_vec input)
        &#34;&#34;&#34;
        out = np.zeros(np.shape(sweep_vec))
        for fn in self.fn_chain:
            this_fn_params = param_ar[fn.this_fn_param_indices]
            out += fn.eval(sweep_vec, *this_fn_params)

        return out

    # =================================

    def residuals_scipyfit(self, param_ar, sweep_vec, pl_val):
        &#34;&#34;&#34;Evaluates residual: fit model - PL value &#34;&#34;&#34;
        return self.__call__(param_ar, sweep_vec) - pl_val

    # =================================

    def jacobian_scipyfit(self, param_ar, sweep_vec, pl_val):
        &#34;&#34;&#34;Evaluates jacobian of fitmodel in format expected by scipy least_squares&#34;&#34;&#34;

        for i, fn in enumerate(self.fn_chain):
            this_fn_params = param_ar[fn.this_fn_param_indices]
            if not i:
                val = fn.grad_fn(sweep_vec, *this_fn_params)
            else:
                val = np.hstack((val, fn.grad_fn(sweep_vec, *this_fn_params)))
        return val


# ====================================================================================


def get_param_defn(fit_model):
    &#34;&#34;&#34;Returns list of parameters in fit_model&#34;&#34;&#34;
    param_defn_ar = []
    for fn in fit_model.fn_chain:
        param_defn_ar.extend(fn.param_defn)
    return param_defn_ar


# =================================


# get ordered dict of key: param name, val: param unit, for all parameters in chain
def get_param_odict(fit_model):
    &#34;&#34;&#34;
    get ordered dict of key: param_key (param_name), val: param_unit for all parameters in fit_model
    &#34;&#34;&#34;
    param_dict = OrderedDict()
    for fn in fit_model.fn_chain:
        for i in range(len(fn.param_defn)):
            param_name = fn.param_defn[i] + &#34;_0&#34;
            param_unit = fn.param_units[fn.param_defn[i]]
            # ensure no overlapping param names
            while param_name in param_dict.keys():
                param_name = param_name[:-1] + str(int(param_name[-1]) + 1)

            param_dict[param_name] = param_unit
    return param_dict


# =================================


def get_param_unit(fit_model, param_name, param_number):
    &#34;&#34;&#34;
    Get unit for a given param_key (given by param_name + &#34;_&#34; + param_number)
    &#34;&#34;&#34;
    param_dict = get_param_odict(fit_model)
    return param_dict[param_name + &#34;_&#34; + str(param_number)]


# ================================================================================================
# ================================================================================================
#
# FitFunc Class
#
# ================================================================================================
# ================================================================================================


class FitFunc:
    &#34;&#34;&#34;Singular fit function&#34;&#34;&#34;

    def __init__(self, param_indices):
        &#34;&#34;&#34;
        Arguments
        ---------
        param_indices : np array
            Where the parameters for this fitfunc are located within broader fitmodel param array.
        &#34;&#34;&#34;
        self.this_fn_param_indices = param_indices

    # =================================

    @staticmethod
    def eval(sweep_vec, *fit_params):
        raise NotImplementedError(&#34;You MUST override eval, check your spelling.&#34;)

    # =================================

    @staticmethod
    def grad_fn(sweep_vec, *fit_params):
        &#34;&#34;&#34; if you want to use a grad_fn override this in the subclass &#34;&#34;&#34;
        return None


# ====================================================================================
# ====================================================================================
#
# Fit Functions themselves
#
# ====================================================================================
# ====================================================================================


# ====================================================================================
# Constant
# ====================================================================================


class Constant(FitFunc):
    &#34;&#34;&#34;Constant&#34;&#34;&#34;

    param_defn = [&#34;constant&#34;]
    param_units = {&#34;constant&#34;: &#34;Amplitude (a.u.)&#34;}

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def eval(x, c):
        &#34;&#34;&#34; speed tested multiple methods, this was the fastest &#34;&#34;&#34;
        ret = np.empty(np.shape(x))
        ret.fill(c)
        return ret

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, c):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 1)}
        &#34;&#34;&#34;
        J = np.empty((x.shape[0], 1))
        J[:, 0] = 1
        return J


# ====================================================================================
# Linear
# ====================================================================================


class Linear(FitFunc):
    &#34;&#34;&#34;Linear function, y=mx+c&#34;&#34;&#34;

    param_defn = [&#34;c&#34;, &#34;m&#34;]
    param_units = {&#34;c&#34;: &#34;Amplitude (a.u.)&#34;, &#34;m&#34;: &#34;Amplitude per Freq (a.u.)&#34;}

    #    def __init__(self, num_peaks):
    #        super().__init__(num_peaks)

    # =================================

    # speed tested, marginally faster with fastmath off (idk why)
    @staticmethod
    @njit(fastmath=False)
    def eval(x, c, m):
        return m * x + c

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def grad_fn(x, c, m):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 2)}
        &#34;&#34;&#34;
        J = np.empty((x.shape[0], 2))
        J[:, 0] = 1
        J[:, 1] = x
        return J


# ====================================================================================
# Circular
# ====================================================================================


class Circular(FitFunc):
    &#34;&#34;&#34;
    Circular function (sine)
    &#34;&#34;&#34;

    param_defn = [&#34;rabi_freq&#34;, &#34;pos_circ&#34;, &#34;amp_circ&#34;]
    param_units = {&#34;rabi_freq&#34;: &#34;Nu (Hz)&#34;, &#34;pos_circ&#34;: &#34;Tau (s)&#34;, &#34;amp_circ&#34;: &#34;Amp (a.u.)&#34;}

    @staticmethod
    @njit
    def eval(x, rabi_freq, pos, amp):
        return amp * np.sin(2 * np.pi * rabi_freq * (x - pos))

    @staticmethod
    @njit
    def grad_fn(x, rabi_freq, pos, amp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;
        # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
        J = np.empty((x.shape[0], 3), dtype=np.float32)
        J[:, 0] = 2 * np.pi * amp * (x - pos) * np.cos(2 * np.pi * rabi_freq * (x - pos))
        J[:, 1] = -2 * np.pi * rabi_freq * amp * np.cos(2 * np.pi * rabi_freq * (x - pos))
        J[:, 2] = np.sin(2 * np.pi * rabi_freq * (x - pos))
        return J


# ====================================================================================
# Gaussians
# ====================================================================================
SCALE_SIGMA = 4 * np.log(2)


class Gaussian(FitFunc):
    &#34;&#34;&#34;Gaussian function&#34;&#34;&#34;

    param_defn = [&#34;fwhm_gauss&#34;, &#34;pos_gauss&#34;, &#34;amp_gauss&#34;]
    param_units = {
        &#34;fwhm_gauss&#34;: &#34;Freq (MHz)&#34;,
        &#34;pos_gauss&#34;: &#34;Freq (MHz)&#34;,
        &#34;amp_gauss&#34;: &#34;Amp (a.u.)&#34;,
    }

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def eval(x, fwhm, pos, amp):
        return amp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm ** 2)


class Gaussian_hyperfine_14(FitFunc):

    param_defn = [
        &#34;pos_gauss_h14&#34;,
        &#34;amp_gauss_h14_hyp_1&#34;,
        &#34;amp_gauss_h14_hyp_2&#34;,
        &#34;amp_gauss_h14_hyp_3&#34;,
        &#34;fwhm_gauss_h14_hyp_1&#34;,
        &#34;fwhm_gauss_h14_hyp_2&#34;,
        &#34;fwhm_gauss_h14_hyp_3&#34;,
    ]
    param_units = {
        &#34;pos_gauss_h14&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_gauss_h14_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h14_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h14_hyp_3&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_gauss_h14_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h14_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h14_hyp_23&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A14 para = -2.14 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
        return (
            amp_1_hyp * np.exp(-SCALE_SIGMA * (x - pos - 2.14) ** 2 / fwhm_1_hyp ** 2)
            + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm_2_hyp ** 2)
            + amp_3_hyp * np.exp(-SCALE_SIGMA * (x - pos + 2.14) ** 2 / fwhm_3_hyp ** 2)
        )


class Gaussian_hyperfine_15(FitFunc):

    param_defn = [
        &#34;pos_gauss_h15&#34;,
        &#34;amp_gauss_h15_hyp_1&#34;,
        &#34;amp_gauss_h15_hyp_2&#34;,
        &#34;fwhm_gauss_h15_hyp_1&#34;,
        &#34;fwhm_gauss_h15_hyp_2&#34;,
    ]
    param_units = {
        &#34;pos_gauss_h15&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_gauss_h15_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h15_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_gauss_h15_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h15_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A15 para = 3.03 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
        return amp_1_hyp * np.exp(
            -SCALE_SIGMA * (x - pos - 1.515) ** 2 / fwhm_1_hyp ** 2
        ) + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos + 1.515) ** 2 / fwhm_2_hyp ** 2)


# ====================================================================================
# Lorentzians
# ====================================================================================


class Lorentzian(FitFunc):
    &#34;&#34;&#34;Lorentzian function&#34;&#34;&#34;

    param_defn = [&#34;fwhm&#34;, &#34;pos&#34;, &#34;amp&#34;]
    param_units = {&#34;fwhm&#34;: &#34;Freq (MHz)&#34;, &#34;pos&#34;: &#34;Freq (MHz)&#34;, &#34;amp&#34;: &#34;Amp (a.u.)&#34;}

    # =================================

    # fastmath gives a ~10% speed up on my testing
    @staticmethod
    @njit(fastmath=True)
    def eval(x, fwhm, pos, amp):
        hwhmsqr = (fwhm ** 2) / 4
        return amp * hwhmsqr / ((x - pos) ** 2 + hwhmsqr)

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, fwhm, pos, amp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;
        # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
        J = np.empty((x.shape[0], 3), dtype=np.float32)
        g = fwhm / 2
        c = pos
        a = amp
        J[:, 0] = ((2 * a * g) / (g ** 2 + (x - c) ** 2)) - (
            (2 * a * g ** 3) / (g ** 2 + (x - c) ** 2) ** 2
        )
        J[:, 1] = (2 * a * g ** 2 * (x - c)) / (g ** 2 + (x - c) ** 2) ** 2
        J[:, 2] = g ** 2 / ((x - c) ** 2 + g ** 2)
        return J


class Lorentzian_hyperfine_14(FitFunc):

    param_defn = [
        &#34;pos_h14&#34;,
        &#34;amp_h14_hyp_1&#34;,
        &#34;amp_h14_hyp_2&#34;,
        &#34;amp_h14_hyp_3&#34;,
        &#34;fwhm_h14_hyp_1&#34;,
        &#34;fwhm_h14_hyp_2&#34;,
        &#34;fwhm_h14_hyp_3&#34;,
    ]
    param_units = {
        &#34;pos_h14&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_h14_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h14_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h14_hyp_3&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_h14_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h14_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h14_hyp_23&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A14 para = -2.14 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
        hwhmsqr1 = (fwhm_1_hyp ** 2) / 4
        hwhmsqr2 = (fwhm_2_hyp ** 2) / 4
        hwhmsqr3 = (fwhm_3_hyp ** 2) / 4
        return (
            amp_1_hyp * hwhmsqr1 / ((x - pos - 2.14) ** 2 + hwhmsqr1)
            + amp_2_hyp * hwhmsqr2 / ((x - pos) ** 2 + hwhmsqr2)
            + amp_3_hyp * hwhmsqr3 / ((x - pos + 2.14) ** 2 + hwhmsqr3)
        )


class Lorentzian_hyperfine_15(FitFunc):

    param_defn = [&#34;pos_h15&#34;, &#34;amp_h15_hyp_1&#34;, &#34;amp_h15_hyp_2&#34;, &#34;fwhm_h15_hyp_1&#34;, &#34;fwhm_h15_hyp_2&#34;]
    param_units = {
        &#34;pos_h15&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_h15_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h15_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_h15_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h15_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A15 para = 3.03 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
        hwhmsqr1 = fwhm_1_hyp ** 2 / 4
        hwhmsqr2 = fwhm_2_hyp ** 2 / 4
        return amp_1_hyp * hwhmsqr1 / (
            (x - pos - 1.515) ** 2 + hwhmsqr1
        ) + amp_2_hyp * hwhmsqr2 / ((x - pos + 1.515) ** 2 + hwhmsqr2)


# ==========================================================================
# Exponential fit functions
# ==========================================================================


class Stretched_exponential(FitFunc):

    param_defn = [&#34;charac_exp_t&#34;, &#34;amp_exp&#34;, &#34;power_exp&#34;]
    param_units = {
        &#34;charac_exp_t&#34;: &#34;Time (s)&#34;,
        &#34;amp_exp&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;power_exp&#34;: &#34;Unitless&#34;,
    }

    # =================================

    @staticmethod
    # njit here not speed tested
    @njit
    def eval(x, charac_exp_t, amp_exp, power_exp):
        return amp_exp * np.exp(-((x / charac_exp_t) ** power_exp))

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, charac_exp_t, amp_exp, power_exp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;

        J = np.empty((x.shape[0], 3), dtype=np.float32)
        # stretched exponential = a * e ^ ((x / t) ^ p)
        # -(a p e^((x/t)^p) (x/t)^p)/t
        J[:, 0] = (1 / charac_exp_t) * (
            amp_exp
            * power_exp
            * np.exp(-((x / charac_exp_t) ** power_exp))
            * (x / charac_exp_t) ** power_exp
        )
        # just lose the &#39;a&#39;
        J[:, 1] = np.exp(-((x / charac_exp_t) ** power_exp))
        # a e^((x/t)^p) (x/t)^p log(x/t)
        J[:, 2] = (
            -amp_exp
            * np.exp(-((x / charac_exp_t) ** power_exp))
            * (x / charac_exp_t) ** power_exp
            * np.log(x / charac_exp_t)
        )
        return J


# ==========================================================================
# ==========================================================================

# careful -&gt; don&#39;t want overlapping param definitions!!!
AVAILABLE_FNS = {
    &#34;lorentzian&#34;: Lorentzian,
    &#34;lorentzian_hyperfine_14&#34;: Lorentzian_hyperfine_14,
    &#34;lorentzian_hyperfine_15&#34;: Lorentzian_hyperfine_15,
    &#34;gaussian&#34;: Gaussian,
    &#34;gaussian_hyperfine_14&#34;: Gaussian_hyperfine_14,
    &#34;gaussian_hyperfine_15&#34;: Gaussian_hyperfine_15,
    &#34;constant&#34;: Constant,
    &#34;linear&#34;: Linear,
    &#34;circular&#34;: Circular,
    &#34;stretched_exponential&#34;: Stretched_exponential,
}
&#34;&#34;&#34;
Dictionary that defines fit functions available for use.

Add any functions you define here so you can use them.

Try not to overlap function parameter names.
&#34;&#34;&#34;


# ==========================================================================
# ==========================================================================</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="QDMPy.fit.models.AVAILABLE_FNS"><code class="name">var <span class="ident">AVAILABLE_FNS</span></code></dt>
<dd>
<div class="desc"><p>Dictionary that defines fit functions available for use.</p>
<p>Add any functions you define here so you can use them.</p>
<p>Try not to overlap function parameter names.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="QDMPy.fit.models.get_param_defn"><code class="name flex">
<span>def <span class="ident">get_param_defn</span></span>(<span>fit_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of parameters in fit_model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_defn(fit_model):
    &#34;&#34;&#34;Returns list of parameters in fit_model&#34;&#34;&#34;
    param_defn_ar = []
    for fn in fit_model.fn_chain:
        param_defn_ar.extend(fn.param_defn)
    return param_defn_ar</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.get_param_odict"><code class="name flex">
<span>def <span class="ident">get_param_odict</span></span>(<span>fit_model)</span>
</code></dt>
<dd>
<div class="desc"><p>get ordered dict of key: param_key (param_name), val: param_unit for all parameters in fit_model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_odict(fit_model):
    &#34;&#34;&#34;
    get ordered dict of key: param_key (param_name), val: param_unit for all parameters in fit_model
    &#34;&#34;&#34;
    param_dict = OrderedDict()
    for fn in fit_model.fn_chain:
        for i in range(len(fn.param_defn)):
            param_name = fn.param_defn[i] + &#34;_0&#34;
            param_unit = fn.param_units[fn.param_defn[i]]
            # ensure no overlapping param names
            while param_name in param_dict.keys():
                param_name = param_name[:-1] + str(int(param_name[-1]) + 1)

            param_dict[param_name] = param_unit
    return param_dict</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.get_param_unit"><code class="name flex">
<span>def <span class="ident">get_param_unit</span></span>(<span>fit_model, param_name, param_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Get unit for a given param_key (given by param_name + "_" + param_number)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param_unit(fit_model, param_name, param_number):
    &#34;&#34;&#34;
    Get unit for a given param_key (given by param_name + &#34;_&#34; + param_number)
    &#34;&#34;&#34;
    param_dict = get_param_odict(fit_model)
    return param_dict[param_name + &#34;_&#34; + str(param_number)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="QDMPy.fit.models.Circular"><code class="flex name class">
<span>class <span class="ident">Circular</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Circular function (sine)</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Circular(FitFunc):
    &#34;&#34;&#34;
    Circular function (sine)
    &#34;&#34;&#34;

    param_defn = [&#34;rabi_freq&#34;, &#34;pos_circ&#34;, &#34;amp_circ&#34;]
    param_units = {&#34;rabi_freq&#34;: &#34;Nu (Hz)&#34;, &#34;pos_circ&#34;: &#34;Tau (s)&#34;, &#34;amp_circ&#34;: &#34;Amp (a.u.)&#34;}

    @staticmethod
    @njit
    def eval(x, rabi_freq, pos, amp):
        return amp * np.sin(2 * np.pi * rabi_freq * (x - pos))

    @staticmethod
    @njit
    def grad_fn(x, rabi_freq, pos, amp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;
        # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
        J = np.empty((x.shape[0], 3), dtype=np.float32)
        J[:, 0] = 2 * np.pi * amp * (x - pos) * np.cos(2 * np.pi * rabi_freq * (x - pos))
        J[:, 1] = -2 * np.pi * rabi_freq * amp * np.cos(2 * np.pi * rabi_freq * (x - pos))
        J[:, 2] = np.sin(2 * np.pi * rabi_freq * (x - pos))
        return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Circular.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Circular.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Circular.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, rabi_freq, pos, amp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit
def eval(x, rabi_freq, pos, amp):
    return amp * np.sin(2 * np.pi * rabi_freq * (x - pos))</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.Circular.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>x, rabi_freq, pos, amp)</span>
</code></dt>
<dd>
<div class="desc"><p 3_="3)" _len_x_="(len(x)," output shape:>Compute the grad of the residue, excluding PL as a param</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit
def grad_fn(x, rabi_freq, pos, amp):
    &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
    {output shape: (len(x), 3)}
    &#34;&#34;&#34;
    # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
    J = np.empty((x.shape[0], 3), dtype=np.float32)
    J[:, 0] = 2 * np.pi * amp * (x - pos) * np.cos(2 * np.pi * rabi_freq * (x - pos))
    J[:, 1] = -2 * np.pi * rabi_freq * amp * np.cos(2 * np.pi * rabi_freq * (x - pos))
    J[:, 2] = np.sin(2 * np.pi * rabi_freq * (x - pos))
    return J</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.Constant"><code class="flex name class">
<span>class <span class="ident">Constant</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Constant</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constant(FitFunc):
    &#34;&#34;&#34;Constant&#34;&#34;&#34;

    param_defn = [&#34;constant&#34;]
    param_units = {&#34;constant&#34;: &#34;Amplitude (a.u.)&#34;}

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def eval(x, c):
        &#34;&#34;&#34; speed tested multiple methods, this was the fastest &#34;&#34;&#34;
        ret = np.empty(np.shape(x))
        ret.fill(c)
        return ret

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, c):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 1)}
        &#34;&#34;&#34;
        J = np.empty((x.shape[0], 1))
        J[:, 0] = 1
        return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Constant.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Constant.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Constant.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<div class="desc"><p>speed tested multiple methods, this was the fastest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, c):
    &#34;&#34;&#34; speed tested multiple methods, this was the fastest &#34;&#34;&#34;
    ret = np.empty(np.shape(x))
    ret.fill(c)
    return ret</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.Constant.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<div class="desc"><p 1_="1)" _len_x_="(len(x)," output shape:>Compute the grad of the residue, excluding PL as a param</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit
def grad_fn(x, c):
    &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
    {output shape: (len(x), 1)}
    &#34;&#34;&#34;
    J = np.empty((x.shape[0], 1))
    J[:, 0] = 1
    return J</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.FitFunc"><code class="flex name class">
<span>class <span class="ident">FitFunc</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitFunc:
    &#34;&#34;&#34;Singular fit function&#34;&#34;&#34;

    def __init__(self, param_indices):
        &#34;&#34;&#34;
        Arguments
        ---------
        param_indices : np array
            Where the parameters for this fitfunc are located within broader fitmodel param array.
        &#34;&#34;&#34;
        self.this_fn_param_indices = param_indices

    # =================================

    @staticmethod
    def eval(sweep_vec, *fit_params):
        raise NotImplementedError(&#34;You MUST override eval, check your spelling.&#34;)

    # =================================

    @staticmethod
    def grad_fn(sweep_vec, *fit_params):
        &#34;&#34;&#34; if you want to use a grad_fn override this in the subclass &#34;&#34;&#34;
        return None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.Circular" href="#QDMPy.fit.models.Circular">Circular</a></li>
<li><a title="QDMPy.fit.models.Constant" href="#QDMPy.fit.models.Constant">Constant</a></li>
<li><a title="QDMPy.fit.models.Gaussian" href="#QDMPy.fit.models.Gaussian">Gaussian</a></li>
<li><a title="QDMPy.fit.models.Gaussian_hyperfine_14" href="#QDMPy.fit.models.Gaussian_hyperfine_14">Gaussian_hyperfine_14</a></li>
<li><a title="QDMPy.fit.models.Gaussian_hyperfine_15" href="#QDMPy.fit.models.Gaussian_hyperfine_15">Gaussian_hyperfine_15</a></li>
<li><a title="QDMPy.fit.models.Linear" href="#QDMPy.fit.models.Linear">Linear</a></li>
<li><a title="QDMPy.fit.models.Lorentzian" href="#QDMPy.fit.models.Lorentzian">Lorentzian</a></li>
<li><a title="QDMPy.fit.models.Lorentzian_hyperfine_14" href="#QDMPy.fit.models.Lorentzian_hyperfine_14">Lorentzian_hyperfine_14</a></li>
<li><a title="QDMPy.fit.models.Lorentzian_hyperfine_15" href="#QDMPy.fit.models.Lorentzian_hyperfine_15">Lorentzian_hyperfine_15</a></li>
<li><a title="QDMPy.fit.models.Stretched_exponential" href="#QDMPy.fit.models.Stretched_exponential">Stretched_exponential</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.FitFunc.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>sweep_vec, *fit_params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eval(sweep_vec, *fit_params):
    raise NotImplementedError(&#34;You MUST override eval, check your spelling.&#34;)</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.FitFunc.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>sweep_vec, *fit_params)</span>
</code></dt>
<dd>
<div class="desc"><p>if you want to use a grad_fn override this in the subclass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def grad_fn(sweep_vec, *fit_params):
    &#34;&#34;&#34; if you want to use a grad_fn override this in the subclass &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.FitModel"><code class="flex name class">
<span>class <span class="ident">FitModel</span></span>
<span>(</span><span>fit_functions)</span>
</code></dt>
<dd>
<div class="desc"><p>FitModel used to fit to data.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>fit_functions</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict of functions to makeup the fit model, key: fitfunc name, val: number of
independent copies of that fitfunc.
format: {"linear": 1, "lorentzian": 8} etc., i.e. options["fit_functions"]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitModel:
    &#34;&#34;&#34;FitModel used to fit to data.&#34;&#34;&#34;

    def __init__(self, fit_functions):
        &#34;&#34;&#34;
        Arguments
        ---------
        fit_functions: dict
            Dict of functions to makeup the fit model, key: fitfunc name, val: number of
            independent copies of that fitfunc.
            format: {&#34;linear&#34;: 1, &#34;lorentzian&#34;: 8} etc., i.e. options[&#34;fit_functions&#34;]
        &#34;&#34;&#34;

        self.fit_functions = fit_functions

        fn_chain = []
        all_param_len = 0

        for fn_type, num_fns in fit_functions.items():
            for i in range(num_fns):
                next_fn = AVAILABLE_FNS[fn_type]  # NOTE: AVAILABLE_FNS defined at end of file
                next_fn_param_len = len(next_fn.param_defn)
                next_fn_param_indices = [all_param_len + i for i in range(next_fn_param_len)]
                all_param_len += next_fn_param_len
                fn_chain.append(next_fn(next_fn_param_indices))

        self.fn_chain = fn_chain

    # =================================

    def __call__(self, param_ar, sweep_vec):
        &#34;&#34;&#34;
        Evaluates fitmodel for given parameter values and sweep (affine) parameter values.

        Arguments
        ---------
        param_ar : np array, 1D
            Array of parameters fed into each fitfunc (these are what are fit by sc)

        sweep_vec : np array, 1D or number
            Affine parameter where the fit model is evaluated

        Returns
        -------
        Fit model evaluates at sweep_vec (output is same format as sweep_vec input)
        &#34;&#34;&#34;
        out = np.zeros(np.shape(sweep_vec))
        for fn in self.fn_chain:
            this_fn_params = param_ar[fn.this_fn_param_indices]
            out += fn.eval(sweep_vec, *this_fn_params)

        return out

    # =================================

    def residuals_scipyfit(self, param_ar, sweep_vec, pl_val):
        &#34;&#34;&#34;Evaluates residual: fit model - PL value &#34;&#34;&#34;
        return self.__call__(param_ar, sweep_vec) - pl_val

    # =================================

    def jacobian_scipyfit(self, param_ar, sweep_vec, pl_val):
        &#34;&#34;&#34;Evaluates jacobian of fitmodel in format expected by scipy least_squares&#34;&#34;&#34;

        for i, fn in enumerate(self.fn_chain):
            this_fn_params = param_ar[fn.this_fn_param_indices]
            if not i:
                val = fn.grad_fn(sweep_vec, *this_fn_params)
            else:
                val = np.hstack((val, fn.grad_fn(sweep_vec, *this_fn_params)))
        return val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="QDMPy.fit.models.FitModel.jacobian_scipyfit"><code class="name flex">
<span>def <span class="ident">jacobian_scipyfit</span></span>(<span>self, param_ar, sweep_vec, pl_val)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates jacobian of fitmodel in format expected by scipy least_squares</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jacobian_scipyfit(self, param_ar, sweep_vec, pl_val):
    &#34;&#34;&#34;Evaluates jacobian of fitmodel in format expected by scipy least_squares&#34;&#34;&#34;

    for i, fn in enumerate(self.fn_chain):
        this_fn_params = param_ar[fn.this_fn_param_indices]
        if not i:
            val = fn.grad_fn(sweep_vec, *this_fn_params)
        else:
            val = np.hstack((val, fn.grad_fn(sweep_vec, *this_fn_params)))
    return val</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.FitModel.residuals_scipyfit"><code class="name flex">
<span>def <span class="ident">residuals_scipyfit</span></span>(<span>self, param_ar, sweep_vec, pl_val)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates residual: fit model - PL value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residuals_scipyfit(self, param_ar, sweep_vec, pl_val):
    &#34;&#34;&#34;Evaluates residual: fit model - PL value &#34;&#34;&#34;
    return self.__call__(param_ar, sweep_vec) - pl_val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.Gaussian"><code class="flex name class">
<span>class <span class="ident">Gaussian</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gaussian(FitFunc):
    &#34;&#34;&#34;Gaussian function&#34;&#34;&#34;

    param_defn = [&#34;fwhm_gauss&#34;, &#34;pos_gauss&#34;, &#34;amp_gauss&#34;]
    param_units = {
        &#34;fwhm_gauss&#34;: &#34;Freq (MHz)&#34;,
        &#34;pos_gauss&#34;: &#34;Freq (MHz)&#34;,
        &#34;amp_gauss&#34;: &#34;Amp (a.u.)&#34;,
    }

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def eval(x, fwhm, pos, amp):
        return amp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm ** 2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Gaussian.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, fwhm, pos, amp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, fwhm, pos, amp):
    return amp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm ** 2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_14"><code class="flex name class">
<span>class <span class="ident">Gaussian_hyperfine_14</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gaussian_hyperfine_14(FitFunc):

    param_defn = [
        &#34;pos_gauss_h14&#34;,
        &#34;amp_gauss_h14_hyp_1&#34;,
        &#34;amp_gauss_h14_hyp_2&#34;,
        &#34;amp_gauss_h14_hyp_3&#34;,
        &#34;fwhm_gauss_h14_hyp_1&#34;,
        &#34;fwhm_gauss_h14_hyp_2&#34;,
        &#34;fwhm_gauss_h14_hyp_3&#34;,
    ]
    param_units = {
        &#34;pos_gauss_h14&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_gauss_h14_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h14_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h14_hyp_3&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_gauss_h14_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h14_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h14_hyp_23&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A14 para = -2.14 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
        return (
            amp_1_hyp * np.exp(-SCALE_SIGMA * (x - pos - 2.14) ** 2 / fwhm_1_hyp ** 2)
            + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm_2_hyp ** 2)
            + amp_3_hyp * np.exp(-SCALE_SIGMA * (x - pos + 2.14) ** 2 / fwhm_3_hyp ** 2)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_14.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_14.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_14.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
    return (
        amp_1_hyp * np.exp(-SCALE_SIGMA * (x - pos - 2.14) ** 2 / fwhm_1_hyp ** 2)
        + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos) ** 2 / fwhm_2_hyp ** 2)
        + amp_3_hyp * np.exp(-SCALE_SIGMA * (x - pos + 2.14) ** 2 / fwhm_3_hyp ** 2)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_15"><code class="flex name class">
<span>class <span class="ident">Gaussian_hyperfine_15</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gaussian_hyperfine_15(FitFunc):

    param_defn = [
        &#34;pos_gauss_h15&#34;,
        &#34;amp_gauss_h15_hyp_1&#34;,
        &#34;amp_gauss_h15_hyp_2&#34;,
        &#34;fwhm_gauss_h15_hyp_1&#34;,
        &#34;fwhm_gauss_h15_hyp_2&#34;,
    ]
    param_units = {
        &#34;pos_gauss_h15&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_gauss_h15_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_gauss_h15_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_gauss_h15_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_gauss_h15_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A15 para = 3.03 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
        return amp_1_hyp * np.exp(
            -SCALE_SIGMA * (x - pos - 1.515) ** 2 / fwhm_1_hyp ** 2
        ) + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos + 1.515) ** 2 / fwhm_2_hyp ** 2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_15.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_15.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Gaussian_hyperfine_15.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
    return amp_1_hyp * np.exp(
        -SCALE_SIGMA * (x - pos - 1.515) ** 2 / fwhm_1_hyp ** 2
    ) + amp_2_hyp * np.exp(-SCALE_SIGMA * (x - pos + 1.515) ** 2 / fwhm_2_hyp ** 2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.fit.models.Linear"><code class="flex name class">
<span>class <span class="ident">Linear</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear function, y=mx+c</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Linear(FitFunc):
    &#34;&#34;&#34;Linear function, y=mx+c&#34;&#34;&#34;

    param_defn = [&#34;c&#34;, &#34;m&#34;]
    param_units = {&#34;c&#34;: &#34;Amplitude (a.u.)&#34;, &#34;m&#34;: &#34;Amplitude per Freq (a.u.)&#34;}

    #    def __init__(self, num_peaks):
    #        super().__init__(num_peaks)

    # =================================

    # speed tested, marginally faster with fastmath off (idk why)
    @staticmethod
    @njit(fastmath=False)
    def eval(x, c, m):
        return m * x + c

    # =================================

    @staticmethod
    @njit(fastmath=True)
    def grad_fn(x, c, m):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 2)}
        &#34;&#34;&#34;
        J = np.empty((x.shape[0], 2))
        J[:, 0] = 1
        J[:, 1] = x
        return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Linear.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Linear.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Linear.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, c, m)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=False)
def eval(x, c, m):
    return m * x + c</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.Linear.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>x, c, m)</span>
</code></dt>
<dd>
<div class="desc"><p 2_="2)" _len_x_="(len(x)," output shape:>Compute the grad of the residue, excluding PL as a param</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def grad_fn(x, c, m):
    &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
    {output shape: (len(x), 2)}
    &#34;&#34;&#34;
    J = np.empty((x.shape[0], 2))
    J[:, 0] = 1
    J[:, 1] = x
    return J</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.Lorentzian"><code class="flex name class">
<span>class <span class="ident">Lorentzian</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Lorentzian function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lorentzian(FitFunc):
    &#34;&#34;&#34;Lorentzian function&#34;&#34;&#34;

    param_defn = [&#34;fwhm&#34;, &#34;pos&#34;, &#34;amp&#34;]
    param_units = {&#34;fwhm&#34;: &#34;Freq (MHz)&#34;, &#34;pos&#34;: &#34;Freq (MHz)&#34;, &#34;amp&#34;: &#34;Amp (a.u.)&#34;}

    # =================================

    # fastmath gives a ~10% speed up on my testing
    @staticmethod
    @njit(fastmath=True)
    def eval(x, fwhm, pos, amp):
        hwhmsqr = (fwhm ** 2) / 4
        return amp * hwhmsqr / ((x - pos) ** 2 + hwhmsqr)

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, fwhm, pos, amp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;
        # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
        J = np.empty((x.shape[0], 3), dtype=np.float32)
        g = fwhm / 2
        c = pos
        a = amp
        J[:, 0] = ((2 * a * g) / (g ** 2 + (x - c) ** 2)) - (
            (2 * a * g ** 3) / (g ** 2 + (x - c) ** 2) ** 2
        )
        J[:, 1] = (2 * a * g ** 2 * (x - c)) / (g ** 2 + (x - c) ** 2) ** 2
        J[:, 2] = g ** 2 / ((x - c) ** 2 + g ** 2)
        return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Lorentzian.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, fwhm, pos, amp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, fwhm, pos, amp):
    hwhmsqr = (fwhm ** 2) / 4
    return amp * hwhmsqr / ((x - pos) ** 2 + hwhmsqr)</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.Lorentzian.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>x, fwhm, pos, amp)</span>
</code></dt>
<dd>
<div class="desc"><p 3_="3)" _len_x_="(len(x)," output shape:>Compute the grad of the residue, excluding PL as a param</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit
def grad_fn(x, fwhm, pos, amp):
    &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
    {output shape: (len(x), 3)}
    &#34;&#34;&#34;
    # Lorentzian: a*g^2/ ((x-c)^2 + g^2)
    J = np.empty((x.shape[0], 3), dtype=np.float32)
    g = fwhm / 2
    c = pos
    a = amp
    J[:, 0] = ((2 * a * g) / (g ** 2 + (x - c) ** 2)) - (
        (2 * a * g ** 3) / (g ** 2 + (x - c) ** 2) ** 2
    )
    J[:, 1] = (2 * a * g ** 2 * (x - c)) / (g ** 2 + (x - c) ** 2) ** 2
    J[:, 2] = g ** 2 / ((x - c) ** 2 + g ** 2)
    return J</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_14"><code class="flex name class">
<span>class <span class="ident">Lorentzian_hyperfine_14</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lorentzian_hyperfine_14(FitFunc):

    param_defn = [
        &#34;pos_h14&#34;,
        &#34;amp_h14_hyp_1&#34;,
        &#34;amp_h14_hyp_2&#34;,
        &#34;amp_h14_hyp_3&#34;,
        &#34;fwhm_h14_hyp_1&#34;,
        &#34;fwhm_h14_hyp_2&#34;,
        &#34;fwhm_h14_hyp_3&#34;,
    ]
    param_units = {
        &#34;pos_h14&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_h14_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h14_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h14_hyp_3&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_h14_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h14_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h14_hyp_23&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A14 para = -2.14 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
        hwhmsqr1 = (fwhm_1_hyp ** 2) / 4
        hwhmsqr2 = (fwhm_2_hyp ** 2) / 4
        hwhmsqr3 = (fwhm_3_hyp ** 2) / 4
        return (
            amp_1_hyp * hwhmsqr1 / ((x - pos - 2.14) ** 2 + hwhmsqr1)
            + amp_2_hyp * hwhmsqr2 / ((x - pos) ** 2 + hwhmsqr2)
            + amp_3_hyp * hwhmsqr3 / ((x - pos + 2.14) ** 2 + hwhmsqr3)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_14.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_14.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_14.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, pos, amp_1_hyp, amp_2_hyp, amp_3_hyp, fwhm_1_hyp, fwhm_2_hyp, fwhm_3_hyp):
    hwhmsqr1 = (fwhm_1_hyp ** 2) / 4
    hwhmsqr2 = (fwhm_2_hyp ** 2) / 4
    hwhmsqr3 = (fwhm_3_hyp ** 2) / 4
    return (
        amp_1_hyp * hwhmsqr1 / ((x - pos - 2.14) ** 2 + hwhmsqr1)
        + amp_2_hyp * hwhmsqr2 / ((x - pos) ** 2 + hwhmsqr2)
        + amp_3_hyp * hwhmsqr3 / ((x - pos + 2.14) ** 2 + hwhmsqr3)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_15"><code class="flex name class">
<span>class <span class="ident">Lorentzian_hyperfine_15</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lorentzian_hyperfine_15(FitFunc):

    param_defn = [&#34;pos_h15&#34;, &#34;amp_h15_hyp_1&#34;, &#34;amp_h15_hyp_2&#34;, &#34;fwhm_h15_hyp_1&#34;, &#34;fwhm_h15_hyp_2&#34;]
    param_units = {
        &#34;pos_h15&#34;: &#34;Frequency (MHz)&#34;,
        &#34;amp_h15_hyp_1&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;amp_h15_hyp_2&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;fwhm_h15_hyp_1&#34;: &#34;Frequency (MHz)&#34;,
        &#34;fwhm_h15_hyp_2&#34;: &#34;Frequency (MHz)&#34;,
    }

    # A15 para = 3.03 MHz
    @staticmethod
    @njit(fastmath=True)
    def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
        hwhmsqr1 = fwhm_1_hyp ** 2 / 4
        hwhmsqr2 = fwhm_2_hyp ** 2 / 4
        return amp_1_hyp * hwhmsqr1 / (
            (x - pos - 1.515) ** 2 + hwhmsqr1
        ) + amp_2_hyp * hwhmsqr2 / ((x - pos + 1.515) ** 2 + hwhmsqr2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_15.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_15.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Lorentzian_hyperfine_15.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit(fastmath=True)
def eval(x, pos, amp_1_hyp, amp_2_hyp, fwhm_1_hyp, fwhm_2_hyp):
    hwhmsqr1 = fwhm_1_hyp ** 2 / 4
    hwhmsqr2 = fwhm_2_hyp ** 2 / 4
    return amp_1_hyp * hwhmsqr1 / (
        (x - pos - 1.515) ** 2 + hwhmsqr1
    ) + amp_2_hyp * hwhmsqr2 / ((x - pos + 1.515) ** 2 + hwhmsqr2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></b></code>:
<ul class="hlist">
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="QDMPy.fit.models.Stretched_exponential"><code class="flex name class">
<span>class <span class="ident">Stretched_exponential</span></span>
<span>(</span><span>param_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Singular fit function</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>param_indices</code></strong> :&ensp;<code>np array</code></dt>
<dd>Where the parameters for this fitfunc are located within broader fitmodel param array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stretched_exponential(FitFunc):

    param_defn = [&#34;charac_exp_t&#34;, &#34;amp_exp&#34;, &#34;power_exp&#34;]
    param_units = {
        &#34;charac_exp_t&#34;: &#34;Time (s)&#34;,
        &#34;amp_exp&#34;: &#34;Amplitude (a.u.)&#34;,
        &#34;power_exp&#34;: &#34;Unitless&#34;,
    }

    # =================================

    @staticmethod
    # njit here not speed tested
    @njit
    def eval(x, charac_exp_t, amp_exp, power_exp):
        return amp_exp * np.exp(-((x / charac_exp_t) ** power_exp))

    # =================================

    @staticmethod
    @njit
    def grad_fn(x, charac_exp_t, amp_exp, power_exp):
        &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
        {output shape: (len(x), 3)}
        &#34;&#34;&#34;

        J = np.empty((x.shape[0], 3), dtype=np.float32)
        # stretched exponential = a * e ^ ((x / t) ^ p)
        # -(a p e^((x/t)^p) (x/t)^p)/t
        J[:, 0] = (1 / charac_exp_t) * (
            amp_exp
            * power_exp
            * np.exp(-((x / charac_exp_t) ** power_exp))
            * (x / charac_exp_t) ** power_exp
        )
        # just lose the &#39;a&#39;
        J[:, 1] = np.exp(-((x / charac_exp_t) ** power_exp))
        # a e^((x/t)^p) (x/t)^p log(x/t)
        J[:, 2] = (
            -amp_exp
            * np.exp(-((x / charac_exp_t) ** power_exp))
            * (x / charac_exp_t) ** power_exp
            * np.log(x / charac_exp_t)
        )
        return J</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="QDMPy.fit.models.Stretched_exponential.param_defn"><code class="name">var <span class="ident">param_defn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="QDMPy.fit.models.Stretched_exponential.param_units"><code class="name">var <span class="ident">param_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="QDMPy.fit.models.Stretched_exponential.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, charac_exp_t, amp_exp, power_exp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# njit here not speed tested
@njit
def eval(x, charac_exp_t, amp_exp, power_exp):
    return amp_exp * np.exp(-((x / charac_exp_t) ** power_exp))</code></pre>
</details>
</dd>
<dt id="QDMPy.fit.models.Stretched_exponential.grad_fn"><code class="name flex">
<span>def <span class="ident">grad_fn</span></span>(<span>x, charac_exp_t, amp_exp, power_exp)</span>
</code></dt>
<dd>
<div class="desc"><p 3_="3)" _len_x_="(len(x)," output shape:>Compute the grad of the residue, excluding PL as a param</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@njit
def grad_fn(x, charac_exp_t, amp_exp, power_exp):
    &#34;&#34;&#34;Compute the grad of the residue, excluding PL as a param
    {output shape: (len(x), 3)}
    &#34;&#34;&#34;

    J = np.empty((x.shape[0], 3), dtype=np.float32)
    # stretched exponential = a * e ^ ((x / t) ^ p)
    # -(a p e^((x/t)^p) (x/t)^p)/t
    J[:, 0] = (1 / charac_exp_t) * (
        amp_exp
        * power_exp
        * np.exp(-((x / charac_exp_t) ** power_exp))
        * (x / charac_exp_t) ** power_exp
    )
    # just lose the &#39;a&#39;
    J[:, 1] = np.exp(-((x / charac_exp_t) ** power_exp))
    # a e^((x/t)^p) (x/t)^p log(x/t)
    J[:, 2] = (
        -amp_exp
        * np.exp(-((x / charac_exp_t) ** power_exp))
        * (x / charac_exp_t) ** power_exp
        * np.log(x / charac_exp_t)
    )
    return J</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#module-variables">Module variables</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QDMPy.fit" href="index.html">QDMPy.fit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="QDMPy.fit.models.AVAILABLE_FNS" href="#QDMPy.fit.models.AVAILABLE_FNS">AVAILABLE_FNS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="QDMPy.fit.models.get_param_defn" href="#QDMPy.fit.models.get_param_defn">get_param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.get_param_odict" href="#QDMPy.fit.models.get_param_odict">get_param_odict</a></code></li>
<li><code><a title="QDMPy.fit.models.get_param_unit" href="#QDMPy.fit.models.get_param_unit">get_param_unit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="QDMPy.fit.models.Circular" href="#QDMPy.fit.models.Circular">Circular</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Circular.eval" href="#QDMPy.fit.models.Circular.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Circular.grad_fn" href="#QDMPy.fit.models.Circular.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.fit.models.Circular.param_defn" href="#QDMPy.fit.models.Circular.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Circular.param_units" href="#QDMPy.fit.models.Circular.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Constant" href="#QDMPy.fit.models.Constant">Constant</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Constant.eval" href="#QDMPy.fit.models.Constant.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Constant.grad_fn" href="#QDMPy.fit.models.Constant.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.fit.models.Constant.param_defn" href="#QDMPy.fit.models.Constant.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Constant.param_units" href="#QDMPy.fit.models.Constant.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.FitFunc" href="#QDMPy.fit.models.FitFunc">FitFunc</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.FitFunc.eval" href="#QDMPy.fit.models.FitFunc.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.FitFunc.grad_fn" href="#QDMPy.fit.models.FitFunc.grad_fn">grad_fn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.FitModel" href="#QDMPy.fit.models.FitModel">FitModel</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.FitModel.jacobian_scipyfit" href="#QDMPy.fit.models.FitModel.jacobian_scipyfit">jacobian_scipyfit</a></code></li>
<li><code><a title="QDMPy.fit.models.FitModel.residuals_scipyfit" href="#QDMPy.fit.models.FitModel.residuals_scipyfit">residuals_scipyfit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Gaussian" href="#QDMPy.fit.models.Gaussian">Gaussian</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Gaussian.eval" href="#QDMPy.fit.models.Gaussian.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian.param_defn" href="#QDMPy.fit.models.Gaussian.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian.param_units" href="#QDMPy.fit.models.Gaussian.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Gaussian_hyperfine_14" href="#QDMPy.fit.models.Gaussian_hyperfine_14">Gaussian_hyperfine_14</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_14.eval" href="#QDMPy.fit.models.Gaussian_hyperfine_14.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_14.param_defn" href="#QDMPy.fit.models.Gaussian_hyperfine_14.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_14.param_units" href="#QDMPy.fit.models.Gaussian_hyperfine_14.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Gaussian_hyperfine_15" href="#QDMPy.fit.models.Gaussian_hyperfine_15">Gaussian_hyperfine_15</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_15.eval" href="#QDMPy.fit.models.Gaussian_hyperfine_15.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_15.param_defn" href="#QDMPy.fit.models.Gaussian_hyperfine_15.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Gaussian_hyperfine_15.param_units" href="#QDMPy.fit.models.Gaussian_hyperfine_15.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Linear" href="#QDMPy.fit.models.Linear">Linear</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Linear.eval" href="#QDMPy.fit.models.Linear.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Linear.grad_fn" href="#QDMPy.fit.models.Linear.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.fit.models.Linear.param_defn" href="#QDMPy.fit.models.Linear.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Linear.param_units" href="#QDMPy.fit.models.Linear.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Lorentzian" href="#QDMPy.fit.models.Lorentzian">Lorentzian</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Lorentzian.eval" href="#QDMPy.fit.models.Lorentzian.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian.grad_fn" href="#QDMPy.fit.models.Lorentzian.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian.param_defn" href="#QDMPy.fit.models.Lorentzian.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian.param_units" href="#QDMPy.fit.models.Lorentzian.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_14" href="#QDMPy.fit.models.Lorentzian_hyperfine_14">Lorentzian_hyperfine_14</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_14.eval" href="#QDMPy.fit.models.Lorentzian_hyperfine_14.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_14.param_defn" href="#QDMPy.fit.models.Lorentzian_hyperfine_14.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_14.param_units" href="#QDMPy.fit.models.Lorentzian_hyperfine_14.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_15" href="#QDMPy.fit.models.Lorentzian_hyperfine_15">Lorentzian_hyperfine_15</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_15.eval" href="#QDMPy.fit.models.Lorentzian_hyperfine_15.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_15.param_defn" href="#QDMPy.fit.models.Lorentzian_hyperfine_15.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Lorentzian_hyperfine_15.param_units" href="#QDMPy.fit.models.Lorentzian_hyperfine_15.param_units">param_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="QDMPy.fit.models.Stretched_exponential" href="#QDMPy.fit.models.Stretched_exponential">Stretched_exponential</a></code></h4>
<ul class="">
<li><code><a title="QDMPy.fit.models.Stretched_exponential.eval" href="#QDMPy.fit.models.Stretched_exponential.eval">eval</a></code></li>
<li><code><a title="QDMPy.fit.models.Stretched_exponential.grad_fn" href="#QDMPy.fit.models.Stretched_exponential.grad_fn">grad_fn</a></code></li>
<li><code><a title="QDMPy.fit.models.Stretched_exponential.param_defn" href="#QDMPy.fit.models.Stretched_exponential.param_defn">param_defn</a></code></li>
<li><code><a title="QDMPy.fit.models.Stretched_exponential.param_units" href="#QDMPy.fit.models.Stretched_exponential.param_units">param_units</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>