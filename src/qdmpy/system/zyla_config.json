{
	// ===========================================================================================
	// ============================ General Parameters ===========================================
	// ===========================================================================================
	// base_dir not required, if not "" it is prepended to filepath
    "base_dir": {}, 
    "filepath": {}, // specify path to raw data. (required)

    // =======================================
    // === Custom output directory control ===
    // Any option key can be interpolated (to options[key]) with braces (like f-strings)
    // e.g. "ODMR_{fit_backend}" -> "ODMR_scipyfit" if the fit backend was scipyfit
    "custom_output_dir_prefix": {
        "option_default": null
    },
    "custom_output_dir_suffix": {
        "option_default": null
    },
    // Must be an absolute path (e.g. from root/C:), will override the path determined internally
    "custom_output_dir": {
        "option_default": null
    },


    // If true the reference (often no-MW) measurement is ignored.
    "ignore_ref": {
        "option_default": false,
        "option_choices":
            [
                true,
                false
            ]
    },

    // additional binning on dataset (local averaging), 0 does nothing. Must be multiple of 2
    "additional_bins": {
        "option_default": 0
    },

    // Name of system used (see systems.py).
    "system_name": {
        "option_default": "Zyla",
        "option_choices":
            [
                "Zyla",
                "Liams_Widefield"
            ]
    },

    "other_measurement_suffixes": {
        "option_default": ["_T.txt", "_IV.txt"]
    },

    // Removes data points from the start and end of each pixel data
    "remove_start_sweep": {
        "option_default": 1
    },
    "remove_end_sweep": {
        "option_default": 0
    },
    // Style of the reference normalisation used. div = division and sub = subtraction
    "normalisation": {
        "option_default": "div",
        "option_choices":
            [
                "div",
                "sub"
            ]
    },
    // how to handle experiment reference (if one found).
    // field: basically everything you would want
    // pre_gslac: provide a dshift reference for single-peak odmr past gslac with 2-peak below gslac.
    //  (can be used with both below gslac, but does require 1/2 peaks in sig/ref along same uNV)
    // inverted_bias: <UNTESTED> if mag stays the same under inverted bias, use this reference to 
    //  remove strain information. 
    //  bnv = (sig_bnv + ref_bnv) / 2 || dshift = GAMMA * (sig_bnv - ref_bnv) / 2 
    "exp_reference_type": {
        "option_default": "field",
        "option_choices":
            [
                "field",
                "pre_gslac",
                "inverted_bias"
            ]
    },

    // =======================================
    // === microscope settings ===
    // Default options for the Zyla microscope
    "microscope_setup": {
        "option_default": {
            "sensor_pixel_size": 6.5e-6,
            "default_objective_mag": 4,
            "default_objective_reference_focal_length":  200e-3,
            "default_camera_tube_lens": 300e-3
        }
    },

    // === override default microscope settings ===
    // provide raw, unbinned pixel size manually 
    // {can be used instead of microscope_setup in system config}
    "pixel_size": {
        "option_default": null
    },
    // pixel_size = sensor_pixel_size * (focal length objective / focal length camera tube lens)
    // where tube lens is the lens that focuses onto the camera, and:
    // focal length objective = objective reference focal length / objective mag
    // leave as null to use defaults (above)
    "objective_mag": {
        "option_default": null
    },
    "objective_reference_focal_length": {
        "option_default": null
    },
    "camera_tube_lens": {
        "option_default": null
    },  

    // =======================================
    // === polygon settings ===
    "polygon_nodes_path": {
        "option_default": null
    },

    "mask_polygons_bground": {
        "option_default": false,
        "option_choices": [
            true,
            false
        ]
    },

    "annotate_polygons": {
        "option_default": false,
        "option_choices": [
            true,
            false
        ]
    },
	// ===========================================================================================
    // ======================== Region Of Interest (ROI) params ==================================
	// ===========================================================================================
    // For taking a region of interest and ignoring the rest of the data set
    "ROI": {
    	"option_default": "Full",
    	"option_choices":
    		[
    			"Full",
    			"Rectangle"    		]
    },
    // Start of ROI region (indices, [start_x, start_y]) i.e. top left corner
    "ROI_start": {
        "option_default": 0
    },    
    // End of ROI region (indices, [end_x, end_y]) i.e. bottom right corner
    "ROI_end": {
        "option_default": 0
    },    

    // ========== Regions for spectra comparision, before full pixel fitting ==========
    // single pixel location that is used
    "single_pixel_check": {
    	"option_default": [1, 1]
    },
    // AOI: area of interest
    // start indices (top left corner) of area 1, [start_x, start_y]
    "AOI_1_start": {
    	"option_default": [1, 1]
    },
    // end indices [end_x, end_y] of the square region of area 1
    "AOI_1_end": {
    	"option_default": [2, 2]
    },
    // etc. for as many as you like: need to be copied/extended below if you want more AOIs
    "AOI_2_start": {
    },
    "AOI_2_end": {
    },
    "AOI_3_start": {
    },
    "AOI_3_end": {
    },
    "AOI_4_start": {
    },
    "AOI_4_end": {
    },
    "AOI_5_start": {
    },
    "AOI_5_end": {
    },
    // ==============================================
    // ========== Pixel Fitting Parameters ==========
    // ==============================================

    // Backend used for pixel fitting
    "fit_backend": {
        "option_default": "scipyfit",
        "option_choices":
            [
                "scipyfit",
                "gpufit"
            ]
    },
    // Backends compared in ROI/AOI spectra comparisons.
    "fit_backend_comparison": {
        "option_default": [
            "scipyfit"
        ]
    },
    // overrides automatic reloading of previous fit results
    "force_fit": {
    	"option_default": false,
    	"option_choices":
    		[
    			true,
    			false
    		]
    }, 
     // fits all of the required pixels, false ignores the pixel fitting
    "fit_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    // fit pixels in a random order to give more accurate ETA
    "scramble_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    // if 'false', uses init guesses below on each pixel, 'true' uses best fit to ROI average
    "use_ROI_avg_fit_res_for_all_pixels": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    // user must set this one: the functions that make up your fit model (required)
    "fit_functions": {},

    // All parameters below can either have a range or a bound.
    // The code automatically detects this by the name of the dictionary key.x
    // range results in bounds of min = guess - range, max = guess + range
    // bounds directly gives these values
    // range takes precedence over bounds

    // Position guess for lorentzian (in MHz)
    "pos_guess": {
    	"option_default": null
    },
    "pos_range": {
    	"option_default": 25
    },

    // Amplitude of peak (trough)
    "amp_guess": {
    	"option_default": -0.0015
    },

    "amp_bounds": {
    	"option_default": [-0.0100, -0.0003]
    },

    // Full width half maximum of the peaks
    "fwhm_guess": {
    	"option_default": 9
    },

    "fwhm_bounds": {
    	"option_default": [3, 40]
    },

    // As above but for Gaussian
    "pos_gauss_guess": {
        "option_default": null
    },
    "pos_gauss_range": {
        "option_default": 25
    },
    "amp_gauss_guess": {
        "option_default": -0.0015
    },

    "amp_gauss_bounds": {
        "option_default": [-0.0100, -0.0003]
    },
    "fwhm_gauss_guess": {
        "option_default": -0.0015
    },

    "fwhm_gauss_bounds": {
        "option_default": [5, 20]
    },

    // linear function (background)
    "c_guess": {
    	"option_default": 1
    },
    "c_bounds": {
    	"option_default": [0.95,1.05]
    },

    "m_guess": {
    	"option_default": 0
    },
    "m_bounds": {
    	"option_default": [-1e-4, 1e-4]
    },

    // constant background
    "constant_guess": {
        "option_default": 1
    },
    "constant_bounds": {
        "option_default": [0.9995, 1.0005]
    },

    // circular function (haven't defined useful defaults)
    "rabi_freq_guess": {
        "option_default": null
    },
    "rabi_freq_bounds": {
        "option_default": [null, null]
    },
    "pos_circ_guess": {
        "option_default": null
    },
    "pos_circ_bounds": {
        "option_default": [null, null]
    },
    "amp_circ_guess": {
        "option_default": null
    },
    "amp_circ_bounds": {
        "option_default": [null, null]
    },

    // Other fit parameters (hyperfine functions)
    "pos_h14_guess": {
        "option_default": null
    },
    "pos_h15_guess": {
        "option_default": null
    },    
    "pos_h14_range": {
        "option_default": 25
    },
    "pos_h15_range": {
        "option_default": 25
    },

    "amp_h15_hyp_1_guess": {
    	"option_default": -0.015
    },
    "amp_h15_hyp_2_guess": {
        "option_default": -0.015
    },

    "amp_h15_hyp_1_bounds": {
    	"option_default": [-0.1, -0.001]
    },
    "amp_h15_hyp_2_bounds": {
    	"option_default": [-0.1, -0.001]
    },

    "amp_h14_hyp_1_guess": {
        "option_default": -0.015
    },
    "amp_h14_hyp_2_guess": {
        "option_default": -0.015
    },
    "amp_h14_hyp_3_guess": {
        "option_default": -0.015
    },

    "amp_h14_hyp_1_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "amp_h14_hyp_2_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "amp_h14_hyp_3_bounds": {
        "option_default": [-0.1, -0.001]
    },

    "fwhm_h15_hyp_1_guess": {
        "option_default": -0.015
    },
    "fwhm_h15_hyp_2_guess": {
        "option_default": -0.015
    },

    "fwhm_h15_hyp_1_bounds": {
        "option_default": [-0.1, -0.001]
    },
    "fwhm_h15_hyp_2_bounds": {
        "option_default": [-0.1, -0.001]
    },

    "fwhm_h14_hyp_1_guess": {
        "option_default": -0.015
    },
    "fwhm_h14_hyp_2_guess": {
        "option_default": -0.015
    },
    "fwhm_h14_hyp_3_guess": {
        "option_default": -0.015
    },

    "power_exp_guess": {
        "option_default": 0.7
    },
    "power_exp_bounds": {
        "option_default": [0.5, 1.0]
    },

    "charac_exp_t_guess": {
        "option_default": 1e-3
    },
    "charac_exp_t_bounds": {
        "option_default": [100e-6, 30e-3]
    },

    "amp_exp_guess": {
        "option_default": -0.07

    },
    "amp_exp_bounds": {
        "option_default": [-0.001, -0.2]
    },

    // ========== Hamiltonian / field retrieval parameters ==========
    // Note: it is assumed the reference experiment is run under the same
    // measurement parameters, except for some single parameter changed
    // (e.g. voltage on/off), thus all of the below settings are used for the
    // reference field retrieval as well. This is to simplify analysis.
    // otherwise, run the field retrieval seperately on each file,
    // then subtract the magnetic fields (etc.) 'manually' before moving on.
    // Only difference is that plotting will not be handled so neatly :)
    
    // do you want to calculate field result for each pixel? (will auto reload prev result)
    "calc_field_pixels": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },

    // force field calculate (don't reload prev. calculation)
    "force_field_calc": {
        "option_default": false,
        "option_choices":
            [
                true,
                false
            ]
    },


    // Method to get bfield from pixel ODMR data
    // options:
    //    - "auto_dc": auto select from number of peaks (+ freqs_to_use)
    //        -> uses ham for 8 peaks, invert_unvs for 6 peaks, prop_single_bnv for 2
    //    - "hamiltonian_fitting": fit full hamiltonian
    //    - "prop_single_bnv": use fourier method to propagate bnv -> bxyz
    //    - "invert_unvs": take 3 unvs and (effective) approx_bxyz hamiltonian, 
    //          but use simple inversion of unv matrix rather than fitting to hamiltonian
    "field_method": {
        "option_default": "auto_dc",
        "option_choices": [
            "auto_dc",
            "hamiltonian_fitting",
            "prop_single_bnv",
            "invert_unvs"
        ]
    },

    // Type of hamiltonian to fit, if that bfield method is used 
    //      (or always fit if not "bxyz" or "approx_bxyz" assuming non-B parameters)
    "hamiltonian": {
        "option_default": "bxyz",
        "option_choices": [
            "bxyz",
            "approx_bxyz"
        ]
    },

    // Which frequencies (e.g. lorentzian posns) to use for field retrieval
    // must be len-8 iterable of values that evaluate as True/False (>=1 must be True)
    "freqs_to_use": {
        "option_default": [1, 1, 1, 1, 1, 1, 1, 1]
    },

    // If option 'prop_single_bnv' given for 'field_method' but number of bnvs calculated
    //  is 2 or 3, this option resolves ambiguity in which bnv to utilize.
    // I.e. you have fit 6 resonances, and want to use 2 to calculate the magnetic field
    //  then the algorithm does know which (physical) resonances using the freqs_to_use option 
    //  above, but not which of the bnv maps this corresponds to.
    // This option is used like so: single_bnv = bnvs[single_unv_choice].
    // Note that `freqs_to_use` must still be set (to use 2 resonances only).
    "single_unv_choice": {
        "option_default": 0
    },

    // Diamond crystal orientation -> see qdmpy.constants. Default: HPHT orientation
    // format: <top face orientation>_<edge face orientation>
    // OR <111>, which only defines one unv (a convenience for single-bnv measurements)
    "diamond_ori": {
        "option_default": "<100>_<100>",
        "option_choices": [
            "<100>_<100>",
            "<100>_<110>",
            "<111>"
        ]
    },
    // Read magnetic field from options (i.e. if applied with vector electromagnet)
    // --> system dependent option (i.e. Unimelb reads from metadata)
    "auto_read_bias": {
        "option_default": false,
        "option_choices": 
            [
                true,
                false
            ]
    },
    // Guess mag field (Bx, By, Bz) from bias field parameters (bias_mag etc.)
    "auto_read_B": {
        "option_default": true,
        "option_choices": 
            [
                true,
                false
            ]
    },
    // To specify unvs directly (below with "unvs" option) instead of guessing from bias_mag etc.
    "use_unvs": {
        "option_default": false,
        "option_choices": 
            [
                true,
                false
            ]
    },
    // unit vectors of NV orientations, must be shape = (4,3). Equiv. to each NV frame's z axis. 
    // (from most-aligned to least aligned with bias field)
    "unvs": {
        "option_default": [
            [0.57735, 0.57735, 0.57735],
            [-0.57735, 0.57735, 0.57735],
            [0.57735, -0.57735, 0.57735],
            [-0.57735, -0.57735, 0.57735]
        ]
    },
    // Field of bias field, used to automatically determine uNVs
    "bias_mag": {
        "option_default": 80
    },
    // in degrees
    "bias_theta": {
        "option_default": 15
    },
    // in degrees
    "bias_phi": {
        "option_default": 15
    },

    // ========== Bfield Fit Parameters ===========
    // directly supply guesses and ranges for bxyz (in Gauss)
    "Bx_guess": {
        "option_default": 10
    },
    "Bx_range": {
        "option_default": 30
    },
    "By_guess": {
        "option_default": 10
    },
    "By_range": {
        "option_default": 30
    },
    "Bz_guess": {
        "option_default": 10
    },
    "Bz_range": {
        "option_default": 30
    },
    "D_guess": {
        "option_default": 2871
    },
    "D_range": {
        "option_default": 5
    },

    // ========== scipy least squares fitting options ===========
    // Method for scipy least squares fitting
    // lm (fast but doesn't use bounds),
    // trf (uses bounds and the most reliable fit method but can be very slow)
    // dogbox (uses bounds and is faster than trf)
    "scipyfit_method": {
        "option_default": "trf",
        "option_choices":
            [
                "lm",
                "trf",
                "dogbox"
            ]
    },
    // number of threads to *not* use for fitting
    "scipyfit_sub_threads": {
        "option_default": 0
    },
     // display progress bar during fitting
    "scipyfit_show_progressbar": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // uses an analytically determined Jacobian, this should be faster but hasn't been implemented 
    // for every function
    // - note it gives different fit results (should be more accurate than a finite-diff method)
    "scipyfit_use_analytic_jac": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // verbose fitting 0 = silent, 1 = term report, 2 display iterations
    "scipyfit_verbose_fitting": {
        "option_default": 0,
        "option_choices": 
            [
                0, 
                1,
                2
            ]
    },
    // The scheme ‘3-point’ is more accurate, but requires twice as many operations 
    // as ‘2-point’ (default).
    // The scheme ‘cs’ uses complex steps, and while potentially the most accurate, it is
    // applicable only when fun correctly handles complex inputs and can be analytically
    // continued to the complex plane.
    "scipyfit_fit_jac_acc":  {
        "option_default": "2-point",
        "option_choices": 
            [
                "2-point", 
                "3-point", 
                "cs"
            ]
    },
    // Tolerance settings, the exact condition depends on method used - see scipy documentation
    // Tolerance for termination by the change of the independent variables.
    "scipyfit_fit_gtol":  {
        "option_default": 1e-12
    },
    // Tolerance for termination by the norm of the gradient.
    "scipyfit_fit_xtol":  {
        "option_default": 1e-12
    },
    // Tolerance for termination by the change of the cost function.
    "scipyfit_fit_ftol": {
        "option_default": 1e-12
    },
    // Rescales the x by the units of the Jacobian (doesn't seem to make a difference)
    "scipyfit_scale_x": {
        "option_default": true,
        "options_choices":
            [
                true,
                false
            ]
    },
    // Determines the loss function. This in non trivial check the scipy documentation
    "scipyfit_loss_fn": {
        "option_default": "linear",
        "option_choices": 
            [
                "linear", 
                "soft_l1", 
                "huber", 
                "cauchy",
                "arctan"
            ]
    },
    // ========== gpufit options ===========
    // Fit tolerance threshold
    // Setting a lower value for the tolerance results in more precise values for the fit 
    // parameters, but requires more fit iterations to reach convergence.
    // A typical value for the tolerance settings is between 1.0E-3 and 1.0E-6.
    // We use 1e-12 in scipy, so I'm using it here too...
    "gpufit_tolerance": {
        "option_default": 1e-12
    },
    // Max number of iterations
    // The maximum number of fit iterations permitted. If the fit has not converged after this 
    // number of iterations, the fit returns with a status value indicating that the maximum 
    // number of iterations was reached.
    "gpufit_max_iterations": {
        "option_default": 25
    },
    // See https://gpufit.readthedocs.io/en/latest/fit_estimator_functions.html
    // default: least squares estimator
    // Use MLE (Maximum likelihood estimator) for data subject to Poisson statistics
    //  ->> Noise in the data is assumed to be purely Poissonian.
    "gpufit_estimator_id": {
        "option_default": "LSE",
        "option_choices": [
            "LSE",
            "MLE"
        ]
    },
    // ===========================================================================================
    // ===============================  Fourier Parameters =======================================
    // ===========================================================================================
    // padding mode, see np.pad
    "fourier_pad_mode": {
        "option_default": "mean",
        "option_choices": [
            "constant",
            "edge",
            "linear_ramp",
            "maximum",
            "mean",
            "median",
            "minimum",
            "reflect",
            "symmetric",
            "wrap",
            "empty"
        ]
    },
    // factor of image dimensions to pad by (on each side, e.g. 2 pad -> 2 either side of imgage)
    "fourier_pad_factor": {
        "option_default": 2
    },
    // add an epsilon value to the k-vectors to avoid some issues with 1/0. False/null/0 to not use
    "fourier_k_vector_epsilon": {
        "option_default": 1e-6
    },
    // use hanning filter in fourier space (for all transformations)
    "fourier_do_hanning_filter": {
        "option_default": true,
        "option_choices": [
            true, 
            false
        ]
    },
    // cutoff freqs (for bandpass) -> give as a distance (k = 2pi/cutoff).
    // e.g. give the diffraction limit for your optical system.
    // if null, high_cutoff is set by standoff (if there is standoff)
    // low_cutoff is not auto-set.
    // if standoff is 0/None/False, no filter is used
    "fourier_high_cutoff": {
        "option_default": null
    },
    "fourier_low_cutoff": {
        "option_default": null
    },

    // True if NVs exist at higher z (in lab frame) than NVs.
    "NVs_above_sample": {
        "option_default": true,
        "option_choices": [
            true,
            false
        ]
    },

    // ===========================================================================================
    // ============================= Source Recon Parameters ====================================
    // ===========================================================================================
    // type of source to reconstruct to
    "source_type": {
        "option_default": "current_density",
        "option_choices": [
            "current_density",
            "magnetisation"
        ]
    },

    // average distance NV layer <-> sample, or null to not use
    "standoff": {
        "option_default": null
    },
    // thickness in metres of NV layer. Not used if standoff is null.
    "nv_layer_thickness": {
        "option_default": null
    },

    // Reconstruction method for B -> J or B -> M
    // see e.g. Broadway 2020 http://dx.doi.org/10.1103/PhysRevApplied.14.024076
    // bz better for magnetisation
    // choices: from_bxy, from_bz, from_bnv
    // must be an array of method you would like to run (even if only 1 choice)
    // from_bnv uses the 'single_unv_choice' option.
    "recon_methods": {
        "option_default": ["from_bxy", "from_bz", "from_bnv"]
    },

    // If using from_bnv, set the index in bnvs (and unvs) to use for current recon. If null, uses 0
    // (i.e. outermost peaks).
    "recon_unv_index": {
        "option_default": null,
        "option_choices": [
            0,
            1,
            2,
            3
        ]
    },

    // Region to use for zero-point normalisation. I.e. mean of this region is subtracted from
    // Jx and Jy (or M etc.). (Or null to not normalise). 
    // Format: [[x_top_left, y_top_left], [x_bot_right, y_bot_right], where y is from top to bottom.
    "zero_point_normalisation_region": {
        "option_default": null
    },

    // normalise each 'line' of in-plane magnetisation reconstruction by subtracting the average
    // value over this many pixels at edge of image. null to not use
    "in_plane_mag_norm_number_pixels": {
        "option_default": null
    },

    // magnetisation direction (intrinsic). Either null/None (for z-magnetisation) or an angle
    // in degress, from (+) x-axis towards (+) y-axis.
    // untested. 
    "magnetisation_angle": {
        "option_default": null
    },

    // ========================================================
    // ========== Background subtraction parameters ===========
    // ========================================================
    // Method for background subtraction (or null to avoid)
    // Descriptions
    // ------------
    //  - fix_zero: constant offset, set zero to chosen value (key 'zero' in bfield_bground_params)
    //  - three_point: plane background, calculated from three points (key 'points')
    //  - mean: constant offset of mean of image
    //  - poly: key 'order' polynomial fit to image
    //  - gaussian: gaussian fit to image
    //  - interpolate: image gaussian filtered (key 'sigma'), with data interpolated over
    //     polygons (key 'interp_method')
    //  - gaussian_filter: image gaussian filtered (key 'sigma')

    // for magnetic fields (bfields)
    "bfield_bground_method": {
        "option_default": null,
        "option_choices": [
            "fix_zero",
            "three_point",
            "mean",
            "poly",
            "gaussian",
            "interpolate",
            "gaussian_filter"
        ]
    },
    // parameters for chosen bground method
    // required:
    //  - fix_zero: 'zero', a number
    //  - three_point: 'points' a length three iterable of [x, y] positions in image
    //  - mean: none
    //  - poly: key 'order', a natural number
    //  - gaussian: none
    //  - interpolate: key 'interp_method' (interpolation method in scipy griddata: nearest, linear, cubic)
    //     and key 'sigma'
    //  - gaussian_filter: requires sigma.
    "bfield_bground_params": {
        "option_default": {}
    },

    // same for bnvs
    "bnv_bground_method":{
        "option_default": null,
        "option_choices": [
            "fix_zero",
            "three_point",
            "mean",
            "poly",
            "gaussian",
            "interpolate",
            "gaussian_filter"
        ]
    },
    "bnv_bground_params": {
        "option_default": {}
    },

    // and for current/magnetisation {and/or use zero_point_normalisation_region}
    "source_bground_method": {
        "option_default": null,
        "option_choices": [
            "fix_zero",
            "three_point",
            "mean",
            "poly",
            "gaussian",
            "interpolate",
            "gaussian_filter"
        ]
    },
    "source_bground_params": {
        "option_default": {}
    },

	// ===========================================================================================
    // =============================== Plotting Parameters =======================================
	// ===========================================================================================
    "save_plots": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    "show_scalebar": {
        "option_default": true,
        "option_choices":
            [
                true,
                false
            ]
    },
    // for ROI/AOI PL plots only
    "annotate_image_regions": {
    	"option_default": true,
    	"option_choices":
    		[
    			true,
    			false
    		]
    },
    "save_fig_type":  {
    	"option_default": "png",
    	"option_choices":
    		[
    			"png",
    			"svg",
    			"pdf"
    		]
    },
    // some figs are huge as svgs (currently just jstream) so this allows them to be set differently
    "large_fig_save_type": {
        "option_default": "png",
        "option_choices":
            [
                "png",
                "svg",
                "pdf"
            ]
    },
    // choose colormap used for each 'type' of image
    "colormaps": {
        "option_default": {
            "param_images": "viridis",
            "residual_images": "inferno",
            "sigma_images": "magma",
            "PL_images": "Greys_r",
            "bnv_images": "RdBu_r",
            "dshift_images": "PRGn",
            "bfield_images": "bwr",
            "source_images": "viridis",
            "current_vector_images": "seismic",
            "current_norm_images": "turbo",
            "current_div_images": "coolwarm",
            "magnetisation_images": "PuOr"
        }
    },
    // Add a minus sign to bnv (and dshift) plots if bias field magnitude (in spherical coords)
    // is negative. Useful to compare magnetic flake bnv images when you're +- the vector bias.
    "plot_bnv_flip_with_bias_mag": {
        "option_default": false
    },
    // =========== Colormap Ranges ===========
    // Choose range of values mapped across to the colormap limits, for each 'type' of image
    // if you want to override, you must copy the full dict (not just the ones you want to change).
    // Available options:
    // type:
    //        min_max                         : map between min and max of image
    //        deviation_from_mean             : maps between (1 - dev) * mean and (1 + dev) * mean.
    // deflt  min_max_symmetric_about_mean    : map symmetrically about mean, capturing all values
    //        min_max_symmetric_about_zero    : map symmetrically about zero, capturing all values
    //        percentile                      : maps the range between percentiles of the data
    //        percentile_symmetric_about_zero : as above but symmetric about zero, caps. all vals
    //        strict_range                    : maps colors between the values given
    //        mean_plus_minus"                : mean plus or minus value given.
    //
    // values : int/float or array
    //    Different for each type:
    //        min_max                         : not used
    //        deviation_from_mean             : ('dev' above) float between 0 and 1
    // deflt  min_max_symmetric_about_mean    : not used
    //        min_max_symmetric_about_zero    : not used
    //        percentile                      : list len 2 of (pref.) ints or floats in [0, 100]
    //        percentile_symmetric_about_zero : list len 2 of (pref.) ints or floats in [0, 100]
    //        strict_range                    : list len 2 of ints/floats
    //        mean_plus_minus                 : int/float.
    //
    // auto_sym_zero : bool
    //    Optional boolean. If True, automatically detects if image has negative and
    //    positive values and makes colormap symmetric about zero. Only has an effect if the
    //    given c_range_type is "min_max" or "percentile".
    //    Defaults to True (i.e. if not specified)
    //
    // implemented in qdmpy.plot.common._get_colormap_range
    "colormap_range_dicts": {
        "option_default": {
            "param_images": {
                "type": "min_max_symmetric_about_mean"
            },
            "residual_images": {
                "type": "min_max"
            },
            "sigma_images": {
                "type": "min_max"
            },
            "PL_images": {
                "type": "min_max"
            },
            "bnv_images": {
                "type": "min_max"
            },
            "dshift_images": {
                "type": "min_max"
            },
            "bfield_images": {
                "type": "min_max"
            },
            "source_images": {
                "type": "min_max"
            },
            "current_vector_images": {
                "type": "percentile",
                "values": [1, 99]
            },
            "current_norm_images": {
                "type": "strict_range",
                "values": [0, 50]
            },
            "current_div_images": {
                "type": "percentile",
                "values": [1, 99]
            },
            "magnetisation_images": {
                "type": "min_max"
            }
        }
    },
    // extra parameters sent to matplotlib to define plotting stylesheet 
    "mpl_rcparams": {
        "option_default": {
            "figure.figsize": [6.4, 4.8],
            "figure.dpi": 80,
            "figure.max_open_warning": 30,
            "lines.linewidth": 0.8,
            "lines.markersize" : 3,
            "xtick.labelsize": 10,
            "xtick.major.size": 4,
            "xtick.direction": "in",
            "ytick.labelsize" : 10,
            "ytick.direction": "in",
            "ytick.major.size": 4,
            "legend.fontsize": "small",
            "legend.loc": "lower left",
            "scalebar.location": "lower right",
            "scalebar.width_fraction": 0.015,
            "scalebar.box_alpha": 0.5,
            "scalebar.scale_loc": "top",
            "scalebar.sep": 1,
            "axes.formatter.useoffset": false,
            "axes.formatter.use_mathtext": true,
            "errorbar.capsize": 3.0
        }
    },
    // parameters for annotating polygon patches onto images (passed to matplotlib.patches.Polygon)
    "polygon_patch_params": {
        "option_default": {
            "facecolor": null,
            "edgecolor": "k",
            "linestyle": "dashed",
            "fill": false
        }
    },
    // colors to identify with each AOI region
    "AOI_colors": {
        "option_default": [
            "blue",
            "tab:brown",
            "purple",
            "darkslategrey",
            "magenta",
            "olive",
            "cyan"
        ]
    },
    "fit_backend_colors": {
        "option_default": {
            "scipyfit": {
                "roifit_linecolor": "mediumblue",
                "residual_linecolor": "black",
                "aoi_roi_fit_linecolor": "indigo",
                "aoi_best_fit_linecolor": "crimson"
            },
            "gpufit": {
                "roifit_linecolor": "cornflowerblue",
                "residual_linecolor": "dimgrey",
                "aoi_roi_fit_linecolor": "mediumpurple",
                "aoi_best_fit_linecolor": "coral"
            }
        }
    },
    // fit options for streamplot (passed as **options["streamplot_options"] to mpl streamplot)
    "streamplot_options" : {
        "option_default": {
            "density": 3,
            "linewidth": 1.0,
            "arrowsize": 0.75
        }
    },
    // alpha (i.e. transparency between 0 (invisible) and 1 (fully opaque)) of PL image behind
    // streamplot
    "streamplot_PL_alpha": {
        "option_default": 1.0
    },
    // Options to create streamplot stream colors. alpha factor: prefactor in tanh that
    // defines the alpha values. low cutoff: values below this are set to an alpha of 0
    // high cutoff: values above this are set to an alpha of 1
    // dynamic range: number of colors to use in cbar  
    // alpha operation:
    // tanh(c (x-d) ) / tanh(c (f-d) )
    // c: ramp factor, d: low cutoff, f: high cutoff
    "streamplot_cbar_options": {
        "option_default": {
            "alpha_ramp_factor": 2,
            "low_cutoff": 0.1,
            "high_cutoff": 1.0,
            "dynamic_range": 1000
        }
    },
    // ===========================================================================================
    // Things set internally, allow to be anything

    // was the options dict (after being read from .json) checked/cleaned?
    "cleaned": {},
    // pointer to system object
    "system": {},
    // flag that we used a reference
    "used_ref": {},
    // metadata dict read in
    "metadata": {},
    // for multiprocessing: # threads to use
    "threads": {},
    // Size of image (size_x, size_y) after rebinning, before being cut down to ROI
    "rebinned_image_shape": {},
    // did we automatically reload a previous fit result?
    "reloaded_prev_fit": {},
    // did we find a previous fit result (that matches current options)?
    "found_prev_result": {},
    // reason for above
    "found_prev_result_reason": {},
    // directory to save results (directly in this dir: images)
    "output_dir": {},
    // directory within output to save data (output_dir/data_dir)
    "data_dir": {},
    // for the record, the parameters (and units) used in this fit model
    "fit_param_defn": {},
    // total (i.e. net) binning used
    "total_bin": {},
    // i.e. labview binning
    "original_bin": {},
    // modelID sent to gpufit (only used if gpufit selected as backend)
    "ModelID": {},
    // CUDA information, stored for the record
    "CUDA_version_runtime": {},
    "CUDA_version_driver": {},
    // time to fit image
    "fit_time_(s)": {},
    // as above but for any hamiltonian fitting
    "ham_fit_time_(s)": {},
    // field result directories
    "field_dir": {},
    "field_sig_dir": {},
    "field_ref_dir": {},
    "field_sig_sub_ref_dir": {},
    "field_method_used" : {},
    // name of field params used in field retrieval model
    "field_params" : {},
    // found previous field calculation result that matches current options
    "found_prev_field_calc": {},
    // reason for above
    "found_prev_field_calc_reason": {},
    // list of list of nodes, a list for each polygon
    "polygon_nodes": {},
    // list of polygon objects
    "polygons": {},
    // source result directory
    "source_dir": {},
    // sorted unvs (from most to least aligned to bias field) used in algorithm
    "unvs_used": {},
    // bias field extracted from metadata/options in different coordinates
    "bias_field_cartesian_gauss": {},
    "bias_field_spherical_deg_gauss": {},
    "ref_bias_field_cartesian_gauss": {},
    "ref_bias_field_spherical_deg_gauss": {}
}
